<?xml version="1.0"?>
<doc>
    <assembly>
        <name>AndyB.Comms</name>
    </assembly>
    <members>
        <member name="T:AndyB.Comms.Interop.Kernel32">
            <summary>
            Win32 Interop functions.
            </summary>
        </member>
        <member name="T:AndyB.Comms.Interop.Kernel32.COMMPROP">
            <summary>
            Contains information about a communications driver.
            </summary>
            <remarks><para>The contents of the <see cref="F:AndyB.Comms.Interop.Kernel32.COMMPROP.dwProvSpec1"/>, <see cref="F:AndyB.Comms.Interop.Kernel32.COMMPROP.dwProvSpec2"/>
            and <see cref="F:AndyB.Comms.Interop.Kernel32.COMMPROP.wcProvChar"/> members depend on the provider subtype (specified by 
            the <see cref="F:AndyB.Comms.Interop.Kernel32.COMMPROP.dwProvSubType"/> member).
            </para>
            <para>If the provider subtype is <see cref="F:AndyB.Comms.Interop.Kernel32.PST_MODEM"/>, these members are used
            as follows:
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <description>Meaning</description>
            </listheader>
            <item><term>dwProvSpec1</term>
            <description>Not used.</description>
            </item>
            <item>
            <term>dwProvSpec2</term>
            <description>Not used.</description></item>
            <item>
            <term>wcProvChar</term>
            <description>Contains a MODEMDEVCAPS structure.</description></item>
            </list>
            </remarks>
            <seealso cref="M:AndyB.Comms.Interop.Kernel32.GetCommProperties(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.COMMPROP@)"/>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMPROP.wPacketLength">
            <summary>
            The size of the entire data packet, regardless of the amount of data requested in bytes.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMPROP.wPacketVersion">
            <summary>
            The version of the packet.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMPROP.dwServiceMask">
            <summary>
            A bitmask indicating which services are implemented by this provider.  The SP_SERIALCOMM value
            is always specified for communications providers, including modem providers.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMPROP.dwReserved1">
            <summary>
            Reserved; do not use.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMPROP.dwMaxTxQueue">
            <summary>
            The maximum size of the driver's internal output buffer in bytes. A value of zero
            indicates that no maximum value is imposed by the serial provider.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMPROP.dwMaxRxQueue">
            <summary>
            The maximum size of the driver's internal input buffer in bytes. A value of zero
            indicates that no maximum value is imposed by the serial provider.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMPROP.dwMaxBaud">
            <summary>
            The maximum allowable baud rate, in bits per second (bps). The member can be one of the
            BAUD_xxx values defined above.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMPROP.dwProvSubType">
            <summary>
            The communications provider type.  One of the PST_xxx values defined above.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMPROP.dwProvCapabilities">
            <summary>
            A bitmask indicating the capabilities offered by the provider. The member can be a combination
            of one of the PCF_xxx values defined above.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMPROP.dwSettableParams">
            <summary>
            A bitmask indicating the communications parameters that can be changed. This member can be
            a combination of the SP_xxx values defined above.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMPROP.dwSettableBaud">
            <summary>
            A bitmask indicating the baudrates that can be used.  For values, see the <see cref="F:AndyB.Comms.Interop.Kernel32.COMMPROP.dwMaxBaud"/>
            member.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMPROP.wSettableData">
            <summary>
            A bitmask indicating the number of databits that can be used. For values, see the above DATA_xxx
            values defined above.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMPROP.wSettableStopParity">
            <summary>
            A bitmask indicating the stop bit and parity bits settings that can be selected. This member can be combination
            of the STOPBITS_xxx and PARITY_xxx values defined above.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMPROP.dwCurrentTxQueue">
            <summary>
            The size of the driver's internal output buffer in bytes. A value of zero indicates that the value is unavailable.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMPROP.dwCurrentRxQueue">
            <summary>
            The size of the driver's internal output buffer in bytes. A value of zero indicates that the value is unavailable.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMPROP.dwProvSpec1">
            <summary>
            Any provider specific data.  Applications should ignore this member unless they have detailed information about the 
            format of data required by the provider.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMPROP.dwProvSpec2">
            <summary>
            Any provider specific data.  Applications should ignore this member unless they have detailed information about the 
            format of data required by the provider.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMPROP.wcProvChar">
            <summary>
            Any provider specific data.  Applications should ignore this member unless they have detailed information about the 
            format of data required by the provider.
            </summary>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.GetCommProperties(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.COMMPROP@)">
            <summary>
            Retrieves information about the communications properties for a specified communications
            device.
            </summary>
            <param name="hFile">A handle to the communications device.  The <see cref="M:AndyB.Comms.Interop.Kernel32.CreateFile(System.String,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)"/>
            method returns this handle.</param>
            <param name="lpCommProp">A pointer to a <see cref="T:AndyB.Comms.Interop.Kernel32.COMMPROP"/> structure in which the communications properties is returned.
            This information can be used in subsequence calls to the <see cref="M:AndyB.Comms.Interop.Kernel32.SetCommState(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.DCB@)"/>,
            <see cref="M:AndyB.Comms.Interop.Kernel32.SetCommTimeouts(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS@)"/>, or <see cref="M:AndyB.Comms.Interop.Kernel32.SetupComm(Microsoft.Win32.SafeHandles.SafeFileHandle,System.UInt32,System.UInt32)"/>
            function to configure the communications device.</param>
            <returns><c>true</c> if the function succeeds; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.SetupComm(Microsoft.Win32.SafeHandles.SafeFileHandle,System.UInt32,System.UInt32)">
            <summary>
            Initialises the communications parameters for a specified communications device.
            </summary>
            <param name="hFile">A handle to the communications device.  The <see cref="M:AndyB.Comms.Interop.Kernel32.CreateFile(System.String,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)"/>
            function returns this handle.</param>
            <param name="dwInQueue">The recommended size of the device's internal input buffer, in bytes.</param>
            <param name="dwOutQueue">The recommended size of the device's internal output buffer, in bytes.</param>
            <returns><para><c>true</c> if the function succeeds; otherwise <c>false</c>.</para>
            <para>To get extended error information, call <see cref="M:AndyB.Comms.Interop.Kernel32.GetLastError"/>.</para></returns>
            <remarks><para>After a process uses the <see cref="M:AndyB.Comms.Interop.Kernel32.CreateFile(System.String,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)"/> function to open a handle to a communications device, but 
            before doing any I/O with the device, it can call <see cref="M:AndyB.Comms.Interop.Kernel32.SetupComm(Microsoft.Win32.SafeHandles.SafeFileHandle,System.UInt32,System.UInt32)"/>SetupComm to set the communications parameters 
            for the device. If it does not set them, the device uses the default parameters when the first call to another communications 
            function occurs.</para>
            <para>The <paramref name="dwInQueue"/> and <paramref name="dwOutQueue"/> parameters specify the recommended sizes for the 
            internal buffers used by the driver for the specified device.For example, YMODEM protocol packets are slightly larger than 
            1024 bytes.Therefore, a recommended buffer size might be 1200 bytes for YMODEM communications.For Ethernet-based communications, 
            a recommended buffer size might be 1600 bytes, which is slightly larger than a single Ethernet frame.
            </para>
            <para>The device driver receives the recommended buffer sizes, but is free to use any input and output (I/O) buffering scheme, 
            as long as it provides reasonable performance and data is not lost due to overrun (except under extreme circumstances). 
            For example, the function can succeed even though the driver does not allocate a buffer, as long as some other portion 
            of the system provides equivalent functionality.
            </para>
            </remarks>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.DTR_CONTROL_DISABLE">
            <summary>
            Disables the DTR line when the device is opened and leaves it disabled.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.DTR_CONTROL_ENABLE">
            <summary>
            Enables the DTR line when the device is opened and leaves it on.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.DTR_CONTROL_HANDSHAKE">
            <summary>
            Enables DTR handshaking. If handshaking is enabled, it is an error for the 
            application to adjust the line by using the EscapeCommFunction function.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.RTS_CONTROL_DISABLE">
            <summary>
            Disables the RTS line when the device is opened and leaves it disabled.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.RTS_CONTROL_ENABLE">
            <summary>
            Enables the RTS line when the device is opened and leaves it on.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.RTS_CONTROL_HANDSHAKE">
            <summary>
            Enables RTS handshaking. The driver raises the RTS line when the 
            "type-ahead" (input) buffer is less than one-half full and lowers the 
            RTS line when the buffer is more than three-quarters full. If handshaking 
            is enabled, it is an error for the application to adjust the line by using 
            the EscapeCommFunction function.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.RTS_CONTROL_TOGGLE">
            <summary>
            Windows NT/2000/XP: Specifies that the RTS line will be high if bytes are 
            available for transmission. After all buffered bytes have been sent, the 
            RTS line will be low.
            </summary>
        </member>
        <member name="T:AndyB.Comms.Interop.Kernel32.DCB">
            <summary>
            The DCB structure defines the control setting for a serial communications device. 
            </summary>
            <seealso cref="M:AndyB.Comms.Interop.Kernel32.SetCommState(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.DCB@)"/>
            <seealso cref="M:AndyB.Comms.Interop.Kernel32.GetCommState(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.DCB@)"/>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.DCB.DCBlength">
            <summary>
            Length, in bytes, of the DCB structure
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.DCB.BaudRate">
            <summary>
            Baud rate at which the communications device operates.
            Supported Rates: 110, 300, 600, 1200, 2400, 4800, 9600
            14400, 19200, 38400, 56000, 57600, 115200, 128000, 256000
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.DCB.bitfield">
            <summary>
            Packed bitfield from win32 struct. 
            </summary>
            fBinary:1 - Indicates whether binary mode is enabled. 
            Windows does not support nonbinary mode transfers, so this member must be TRUE.
              
            fParity:1 - Indicates whether parity checking is enabled. 
            If this member is TRUE, parity checking is performed and errors are reported. 
            
            fOutxCtsFlow:1 - Indicates whether the CTS (clear-to-send) signal is monitored 
            for output flow control. If this member is TRUE and CTS is turned off, output 
            is suspended until CTS is sent again. 
            
            fOutxDsrFlow:1 - Indicates whether the DSR (data-set-ready) signal is monitored 
            for output flow control. If this member is TRUE and DSR is turned off, output is 
            suspended until DSR is sent again. 
            
            fDtrControl:2 - DTR (data-terminal-ready) flow control. This member can be one 
            of the following values. 
            	DTR_CONTROL_DISABLE		Disables the DTR line when the device is opened and
            							leaves it disabled. 
            	DTR_CONTROL_ENABLE		Enables the DTR line when the device is opened and
            							leaves it on. 
            	DTR_CONTROL_HANDSHAKE	Enables DTR handshaking. If handshaking is enabled,
            							it is an error for the application to adjust the line
            							by using the EscapeCommFunction function. 
            
            fDsrSensitivity:1 - Indicates whether the communications driver is sensitive to 
            the state of the DSR signal. If this member is TRUE, the driver ignores any bytes 
            received, unless the DSR modem input line is high. 
            
            fTXContinueOnXoff:1 - Indicates whether transmission stops when the input buffer 
            is full and the driver has transmitted the XoffChar character. If this member is 
            TRUE, transmission continues after the input buffer has come within XoffLim bytes 
            of being full and the driver has transmitted the XoffChar character to stop 
            receiving bytes. If this member is FALSE, transmission does not continue until 
            the input buffer is within XonLim bytes of being empty and the driver has 
            transmitted the XonChar character to resume reception. 
            
            fOutX:1 - Indicates whether XON/XOFF flow control is used during transmission. 
            If this member is TRUE, transmission stops when the XoffChar character is received 
            and starts again when the XonChar character is received.
            
            fInX:1 -  Indicates whether XON/XOFF flow control is used during reception. 
            If this member is TRUE, the XoffChar character is sent when the input buffer 
            comes within XoffLim bytes of being full, and the XonChar character is sent 
            when the input buffer comes within XonLim bytes of being empty. 
            
            fErrorChar: 1 -  Indicates whether bytes received with parity errors are replaced 
            with the character specified by the ErrorChar member. If this member is TRUE and 
            the fParity member is TRUE, replacement occurs.
            
            fNull:1 - Indicates whether null bytes are discarded. If this member is TRUE, 
            null bytes are discarded when received.
            
            fRtsControl:2 - RTS (request-to-send) flow control. This member can be one of the 
            following values.
            	RTS_CONTROL_DISABLE		Disables the RTS line when the device is opened and 
            							leaves it disabled. 
            	RTS_CONTROL_ENABLE		Enables the RTS line when the device is opened and 
            							leaves it on. 
            	RTS_CONTROL_HANDSHAKE	Enables RTS handshaking. The driver raises the RTS line
            							when the "type-ahead" (input) buffer is less than 1/2 
            							full and lowers the RTS line when the buffer is more than
            							three-quarters full. If handshaking is enabled, it is 
            							an error for the application to adjust the line by using
            							the EscapeCommFunction function.
            	RTS_CONTROL_TOGGLE		Windows NT/2000/XP: Specifies that the RTS line will be
            							high if bytes are available for transmission. After all
            							buffered bytes have been sent, the RTS line will be low. 
            
            fAbortOnError:1 - Indicates whether read and write operations are terminated if an 
            error occurs. If this member is TRUE, the driver terminates all read and write 
            operations with an error status if an error occurs. The driver will not accept 
            any further communications operations until the application has acknowledged the 
            error by calling the ClearCommError function.
            
            fDummy2:17 - Reserved; do not use. 
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.DCB.wReserved">
            <summary>
            Reserved; must be zero.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.DCB.XonLim">
            <summary>
            Minimum number of bytes allowed in the input buffer before flow control 
            is activated to inhibit the sender. Note that the sender may transmit 
            characters after the flow control signal has been activated, so this value 
            should never be zero. This assumes that either XON/XOFF, RTS, or DTR input 
            flow control is specified in fInX, fRtsControl, or fDtrControl.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.DCB.XoffLim">
            <summary>
            Maximum number of bytes allowed in the input buffer before flow control 
            is activated to allow transmission by the sender. This assumes that either 
            XON/XOFF, RTS, or DTR input flow control is specified in fInX, fRtsControl, 
            or fDtrControl. The maximum number of bytes allowed is calculated by 
            subtracting this value from the size, in bytes, of the input buffer.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.DCB.ByteSize">
            <summary>
            Number of bits in the bytes transmitted and received. 
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.DCB.Partity">
            <summary>
            Parity scheme to be used. This member can be one of the following values.
            Even, Mark, None, Odd, Space 
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.DCB.StopBits">
            <summary>
            Number of stop bits to be used. This member can be 1, 1.5, or 2 stop bits.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.DCB.XonChar">
            <summary>
            Value of the XON character for both transmission and reception. 
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.DCB.XoffChar">
            <summary>
            Value of the XOFF character for both transmission and reception. 
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.DCB.ErrorChar">
            <summary>
            Value of the character used to replace bytes received with a parity error.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.DCB.EofChar">
            <summary>
            Value of the character used to signal the end of data.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.DCB.EvtChar">
            <summary>
            Value of the character used to signal an event.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.DCB.wReserved1">
            <summary>
            Reserved; do not use.
            </summary>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.GetCommState(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.DCB@)">
            <summary>
            The GetCommState function retrieves the current control settings for a specified communications device.
            </summary>
            <param name="hFile">A handle to the communications device. The <see cref="M:AndyB.Comms.Interop.Kernel32.CreateFile(System.String,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)"/>
            function returns this handle.</param>
            <param name="lpDCB">A pointer to a <see cref="T:AndyB.Comms.Interop.Kernel32.DCB"/> structure that receives the control settings information.</param>
            <returns><para><c>true</c> if the function succeeds; otherwise <c>false</c>.</para>
            <para>To get extended error information, call <see cref="M:AndyB.Comms.Interop.Kernel32.GetLastError"/></para>.</returns>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.SetCommState(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.DCB@)">
            <summary>
            The SetCommState function configures a communications device according to the specifications in a device control block 
            (a <see cref="T:AndyB.Comms.Interop.Kernel32.DCB"/> structure). The function reinitializes all hardware and control settings, but it does not empty 
            output or input queues.
            </summary>
            <param name="hFile">A handle to the communications device. The <see cref="M:AndyB.Comms.Interop.Kernel32.CreateFile(System.String,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)"/>
            function returns this handle.</param>
            <param name="lpDCB">A pointer to a <see cref="T:AndyB.Comms.Interop.Kernel32.DCB"/> structure that receives the control settings information.</param>
            <returns><para><c>true</c> if the function succeeds; otherwise <c>false</c>.</para>
            <para>To get extended error information, call <see cref="M:AndyB.Comms.Interop.Kernel32.GetLastError"/></para>.</returns>
            <remarks><para>The <see cref="M:AndyB.Comms.Interop.Kernel32.SetCommState(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.DCB@)"/> function uses a <see cref="T:AndyB.Comms.Interop.Kernel32.DCB"/> structure to specify the desired configuration. 
            The <see cref="M:AndyB.Comms.Interop.Kernel32.GetCommState(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.DCB@)"/> function returns the current configuration.
            </para>
            <para>To set only a few members of the <see cref="T:AndyB.Comms.Interop.Kernel32.DCB"/> structure, you should modify a <see cref="T:AndyB.Comms.Interop.Kernel32.DCB"/> structure that has 
            been filled in by a call to <see cref="M:AndyB.Comms.Interop.Kernel32.GetCommState(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.DCB@)"/> . This ensures that the other members of the <see cref="T:AndyB.Comms.Interop.Kernel32.DCB"/> structure 
            have appropriate values.</para>
            <para>The <see cref="M:AndyB.Comms.Interop.Kernel32.SetCommState(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.DCB@)"/> function fails if the <see cref="F:AndyB.Comms.Interop.Kernel32.DCB.XonChar"/> member of the <see cref="T:AndyB.Comms.Interop.Kernel32.DCB"/> structure 
            is equal to the <see cref="F:AndyB.Comms.Interop.Kernel32.DCB.XoffChar"/> member.</para>
            <para>When <see cref="M:AndyB.Comms.Interop.Kernel32.SetCommState(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.DCB@)"/> is used to configure the 8250, the following restrictions apply to the values for the 
            <see cref="T:AndyB.Comms.Interop.Kernel32.DCB"/> structure's <see cref="F:AndyB.Comms.Interop.Kernel32.DCB.ByteSize"/> and <see cref="F:AndyB.Comms.Interop.Kernel32.DCB.StopBits"/> members:</para>
            <para>The number of data bits must be 5 to 8.</para>
            </remarks>
        </member>
        <member name="T:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS">
            <summary>
            The COMMTIMEOUTS structure is used in the <see cref="M:AndyB.Comms.Interop.Kernel32.SetCommTimeouts(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS@)"/> and <see cref="M:AndyB.Comms.Interop.Kernel32.GetCommTimeouts(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS@)"/>
            functions to set and query the time-out parameters for a communications device. 
            The parameters determine the behaviour of <see cref="M:AndyB.Comms.Interop.Kernel32.ReadFile(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Byte*,System.Int32,System.IntPtr,System.Threading.NativeOverlapped*)"/>, 
            <see cref="M:AndyB.Comms.Interop.Kernel32.WriteFile(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Byte*,System.Int32,System.IntPtr,System.Threading.NativeOverlapped*)"/>WriteFile, ReadFileEx, and 
            WriteFileEx operations on the device.
            </summary>
            <remarks><para>If an application sets <see cref="F:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS.ReadIntervalTimeout"/> and <see cref="F:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS.ReadTotalTimeoutMultiplier"/> to 
            MAXDWORD and sets <see cref="F:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS.ReadTotalTimeoutConstant"/> to a value greater than zero and less than MAXDWORD, one of the 
            following occurs when the <see cref="M:AndyB.Comms.Interop.Kernel32.ReadFile(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Byte*,System.Int32,System.IntPtr,System.Threading.NativeOverlapped*)"/> function is called:
            </para>
            <list type="bullet">
            <item>If there are any bytes in the input buffer, ReadFile returns immediately with the bytes in the buffer.</item>
            <item>If there are no bytes in the input buffer, ReadFile waits until a byte arrives and then returns immediately.</item>
            <item>If no bytes arrive within the time specified by <see cref="F:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS.ReadTotalTimeoutConstant"/>, ReadFile times out.</item>
            </list></remarks>
            <seealso cref="M:AndyB.Comms.Interop.Kernel32.SetCommTimeouts(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS@)"/>
            <seealso cref="M:AndyB.Comms.Interop.Kernel32.GetCommTimeouts(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS@)"/>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS.ReadIntervalTimeout">
            <summary>
            <para>The maximum time allowed to elapse before the arrival of the next byte on the communications line, in milliseconds. 
            If the interval between the arrival of any two bytes exceeds this amount, the <see cref="M:AndyB.Comms.Interop.Kernel32.ReadFile(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Byte*,System.Int32,System.IntPtr,System.Threading.NativeOverlapped*)"/>
            operation is completed and any buffered data is returned. A value of zero indicates that interval time-outs are not used.
            </para>
            <para>A value of MAXDWORD, combined with zero values for both the <see cref="F:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS.ReadTotalTimeoutConstant"/> and 
            <see cref="F:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS.ReadTotalTimeoutMultiplier"/> members, specifies that the read operation is to return immediately 
            with the bytes that have already been received, even if no bytes have been received.
            </para>
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS.ReadTotalTimeoutMultiplier">
            <summary>
            The multiplier used to calculate the total time-out period for read operations, in milliseconds. For each read operation, 
            this value is multiplied by the requested number of bytes to be read.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS.ReadTotalTimeoutConstant">
            <summary>
            <para>A constant used to calculate the total time-out period for read operations, in milliseconds. 
            For each read operation, this value is added to the product of the <see cref="F:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS.ReadTotalTimeoutMultiplier"/> 
            member and the requested number of bytes.</para>
            <para>A value of zero for both the <see cref="F:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS.ReadTotalTimeoutMultiplier"/> and <see cref="F:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS.ReadTotalTimeoutConstant"/>
            members indicates that total time-outs are not used for read operations.</para>
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS.WriteTotalTimeoutMultiplier">
            <summary>
            The multiplier used to calculate the total time-out period for write operations, in milliseconds. For each write operation, 
            this value is multiplied by the number of bytes to be written.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS.WriteTotalTimeoutConstant">
            <summary>
            <para>A constant used to calculate the total time-out period for write operations, in milliseconds. For each write operation, 
            this value is added to the product of the <see cref="F:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS.WriteTotalTimeoutMultiplier"/> member and the number of bytes to be written.
            </para>
            <para>A value of zero for both the <see cref="F:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS.WriteTotalTimeoutMultiplier"/> and <see cref="F:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS.WriteTotalTimeoutConstant"/> members 
            indicates that total time-outs are not used for write operations.
            </para>
            </summary>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.GetCommTimeouts(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS@)">
            <summary>
            The GetCommTimeouts function retrieves the time-out parameters for
            all read and write operations on a specified communications device.
            </summary>
            <param name="hFile">A handle to the communications device. A call to <see cref="M:AndyB.Comms.Interop.Kernel32.CreateFile(System.String,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)"/>
            returns this handle.</param>
            <param name="lpCommTimeouts">A pointer to a <see cref="T:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS"/> structure that contains the new
            time-out values.</param>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.SetCommTimeouts(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS@)">
            <summary>
            The SetCommTimeouts function sets the time-out parameters for all read and 
            write operations on a specified communications device.
            </summary>
            <param name="hFile">A handle to the communications device. A call to <see cref="M:AndyB.Comms.Interop.Kernel32.CreateFile(System.String,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)"/>
            returns this handle.</param>
            <param name="lpCommTimeouts">A pointer to a <see cref="T:AndyB.Comms.Interop.Kernel32.COMMTIMEOUTS"/> structure that contains the new
            time-out values.</param>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.CommEvent.RxChar">
            <summary>
            A character was received and placed in the input buffer.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.CommEvent.RxFlag">
            <summary>
            The event character was received and placed in the input buffer.
            The event character is specified in the device's <see cref="T:AndyB.Comms.Interop.Kernel32.DCB"/> structure,
            which is applied to a serial port by using the <see cref="M:AndyB.Comms.Interop.Kernel32.SetCommState(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.DCB@)"/>.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.CommEvent.TxEmpty">
            <summary>
            The last character in the output buffer was sent.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.CommEvent.Cts">
            <summary>
            The CTS (clear-to-send) signal changed state.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.CommEvent.Dsr">
            <summary>
            The DSR (data-set-ready) signal changed state.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.CommEvent.Rlsd">
            <summary>
            The RLSD (receive-line-signal-detect) signal changed state.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.CommEvent.Break">
            <summary>
            A break was detected on input.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.CommEvent.Error">
            <summary>
            A line-status error occurred. Line-status errors are 
            CE_FRAME, CE_OVERRUN, CE_IOE, CE_TXFULL, CE_RXOVER and CE_RXPARITY.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.CommEvent.Ring">
            <summary>
            A ring indicator was detected.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.CommEvent.Default">
            <summary>
            All events.
            </summary>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.GetCommMask(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IntPtr@)">
            <summary>
            The GetCommMask function retrieves the value of the event mask 
            for a specified communications device.
            </summary>
            <param name="hFile">A handle to the communications device. The <see cref="M:AndyB.Comms.Interop.Kernel32.CreateFile(System.String,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)"/>
            function returns this handle.</param>
            <param name="lpEvtMask">A pointer to the variable that receives a mask of events that are currently enabled. This value
            can be one of the EV_xxx values declared above.</param>
            <returns><c>true</c> if the function succeeds; otherwise <c>false</c>.</returns>
            <remarks><para>The <see cref="M:AndyB.Comms.Interop.Kernel32.GetCommMask(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IntPtr@)"/> function uses a mask variable to indicate the set of events that can be monitored 
            for a particular communications resource. A handle to the communications resource can be specified in a call to the 
            <see cref="M:AndyB.Comms.Interop.Kernel32.WaitCommEvent(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.CommEvent*,System.Threading.NativeOverlapped*)"/> function, which waits for one of the events to occur. To 
            modify the event mask of a communications resource, use the <see cref="M:AndyB.Comms.Interop.Kernel32.SetCommMask(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.CommEvent)"/> function.</para></remarks>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.SetCommMask(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.CommEvent)">
            <summary>
            The SetCommMask function specifies a set of events to be monitored 
            for a communications device.
            </summary>
            <param name="hFile">A handle to the communications device. The <see cref="M:AndyB.Comms.Interop.Kernel32.CreateFile(System.String,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)"/>
            function returns this handle.</param>
            <param name="dwEvtMask">The events to be enabled. A value of 0 disables all events. This parameter is one or more of the 
            EV_xxx values declared above.</param>
            <returns><c>true</c> if the function succeeds; otherwise <c>false</c>.</returns>
            <remarks><para>The <see cref="M:AndyB.Comms.Interop.Kernel32.SetCommMask(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.CommEvent)"/> function specifies the set of events that can be monitored 
            for a particular communications resource. A handle to the communications resource can be specified in a call to the 
            <see cref="M:AndyB.Comms.Interop.Kernel32.WaitCommEvent(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.CommEvent*,System.Threading.NativeOverlapped*)"/> function, which waits for one of the events to occur. 
            To get the current event mask of a communications resource, use the <see cref="M:AndyB.Comms.Interop.Kernel32.GetCommMask(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IntPtr@)"/> function.</para></remarks>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.WaitCommEvent(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.CommEvent*,System.Threading.NativeOverlapped*)">
            <summary>
            The WaitCommEvent function waits for an event to occur 
            for a specified communications device. The set of events 
            that are monitored by this function is contained in the 
            event mask associated with the device handle. 
            </summary>
            <param name="hFile">A handle to the communications device. A call to <see cref="M:AndyB.Comms.Interop.Kernel32.CreateFile(System.String,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)"/>
            returns this handle.</param>
            <param name="lpEvtMask">A pointer to a variable which receives a mask indicating the type of event that occurred. If an
            error occurs, the value is zero; otherwise it is one of the EV_xxx values.</param>
            <param name="lpOverlapped"><para>A pointer to an <see cref="T:System.Threading.NativeOverlapped"/> structure. This structure is required if the
            <paramref name="hFile"/> was opened with <see cref="F:AndyB.Comms.Interop.Kernel32.FILE_FLAG_OVERLAPPED"/>.</para>
            <para>If <paramref name="hFile"/> was opened with <see cref="F:AndyB.Comms.Interop.Kernel32.FILE_FLAG_OVERLAPPED"/>, the <paramref name="lpOverlapped"/> parameter 
            must not be <c>null</c> . It must point to a valid <see cref="T:System.Threading.NativeOverlapped"/> structure. If <paramref name="hFile"/> was opened with 
            <see cref="F:AndyB.Comms.Interop.Kernel32.FILE_FLAG_OVERLAPPED"/> and <paramref name="lpOverlapped"/> is <c>null</c>, the function can incorrectly report that the 
            operation is complete.</para>
            <para>If <paramref name="hFile"/> was opened with <see cref="F:AndyB.Comms.Interop.Kernel32.FILE_FLAG_OVERLAPPED"/> and <paramref name="lpOverlapped"/>is not <c>null</c>, 
            <see cref="M:AndyB.Comms.Interop.Kernel32.WaitCommEvent(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.CommEvent*,System.Threading.NativeOverlapped*)"/> is performed as an overlapped operation. In this case, the 
            <see cref="T:System.Threading.NativeOverlapped"/> structure must contain a handle to a manual-reset event object (created by using the CreateEvent function).</para>
            <para>If <paramref name="hFile"/> was not opened with <see cref="F:AndyB.Comms.Interop.Kernel32.FILE_FLAG_OVERLAPPED"/>, <see cref="M:AndyB.Comms.Interop.Kernel32.WaitCommEvent(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.CommEvent*,System.Threading.NativeOverlapped*)"/> 
            does not return until one of the specified events or an error occurs.</para>
            </param>
            <returns><c>true</c> if the function succeeds; otherwise <c>false</c>.</returns>
            <remarks><para>The <see cref="M:AndyB.Comms.Interop.Kernel32.WaitCommEvent(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.CommEvent*,System.Threading.NativeOverlapped*)"/> function monitors a set of events for a specified 
            communications resource. To set and query the current event mask of a communications resource, use the <see cref="M:AndyB.Comms.Interop.Kernel32.SetCommMask(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.CommEvent)"/>
            and <see cref="M:AndyB.Comms.Interop.Kernel32.GetCommMask(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IntPtr@)"/> functions.
            </para>
            <para>If the overlapped operation cannot be completed immediately, the function returns <c>false</c> and the <see cref="M:AndyB.Comms.Interop.Kernel32.GetLastError"/>
             function returns <see cref="F:AndyB.Comms.Interop.Kernel32.ERROR_IO_PENDING"/>, indicating that the operation is executing in the background. When this happens, 
             the system sets the <see cref="F:System.Threading.NativeOverlapped.EventHandle"/> member of the <see cref="T:System.Threading.NativeOverlapped"/> structure to the 
             not-signalled state before <see cref="M:AndyB.Comms.Interop.Kernel32.WaitCommEvent(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.CommEvent*,System.Threading.NativeOverlapped*)"/> returns, and then it sets it to the 
             signalled state when one of the specified events or an error occurs. The calling process can use one of the wait functions to 
             determine the event object's state and then use the GetOverlappedResult function to determine the results of the 
             <see cref="M:AndyB.Comms.Interop.Kernel32.WaitCommEvent(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.CommEvent*,System.Threading.NativeOverlapped*)"/> operation. GetOverlappedResult reports the success or 
             failure of the operation, and the variable pointed to by the <paramref name="lpEvtMask"/> parameter is set to indicate the event 
             that occurred.</para>
            <para>If a process attempts to change the device handle's event mask by using the <see cref="M:AndyB.Comms.Interop.Kernel32.SetCommMask(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.CommEvent)"/>
            function while an overlapped <see cref="M:AndyB.Comms.Interop.Kernel32.WaitCommEvent(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.CommEvent*,System.Threading.NativeOverlapped*)"/> operation is in progress, 
            <see cref="M:AndyB.Comms.Interop.Kernel32.WaitCommEvent(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.CommEvent*,System.Threading.NativeOverlapped*)"/> returns immediately. The variable pointed to by the 
            <paramref name="lpEvtMask"/> parameter is set to zero.</para>
            </remarks>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.GetCommModemStatus(System.Runtime.InteropServices.SafeHandle,AndyB.Comms.Serial.ModemStatus@)">
            <summary>
            Retrieves the modem control-register value.
            </summary>
            <param name="hFile">A handle to a communications device.  The <see cref="M:AndyB.Comms.Interop.Kernel32.CreateFile(System.String,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)"/>
            function will return a handle.</param>
            <param name="lpModemStat">A pointer to a variable that receives the current state of the modem control-registers value.
            This parameter is one of the <see cref="T:AndyB.Comms.Serial.ModemStatus"/> enumeration.</param>
        </member>
        <member name="T:AndyB.Comms.Interop.Kernel32.COMMSTAT">
            <summary>
            The COMMSTAT structure contains information about a communications 
            device. This structure is filled by the ClearCommError function.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMSTAT.bitfield">
            <summary>
            Packed status bitfield.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMSTAT.cbInQue">
            <summary>
            Number of bytes received by the serial provider 
            but not yet read by a ReadFile operation.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.COMMSTAT.cbOutQue">
            <summary>
            Number of bytes of user data remaining to be 
            transmitted for all write operations. This value 
            will be zero for a non-overlapped write.
            </summary>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.ClearCommError(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Serial.SerialError@,AndyB.Comms.Interop.Kernel32.COMMSTAT@)">
            <summary>
            The ClearCommError function retrieves information about a 
            communications error and reports the current status of a 
            communications device. The function is called when a 
            communications error occurs, and it clears the device's 
            error flag to enable additional input and output (I/O) operations.
            </summary>
            <param name="hFile">A handle to the communications device. The <see cref="M:AndyB.Comms.Interop.Kernel32.CreateFile(System.String,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)"/>
            function returns a handle.</param>
            <param name="lpErrors">A pointer to a variable that receives the mask indicating the type of error.</param>
            <param name="lpStat">A pointer to a <see cref="T:AndyB.Comms.Interop.Kernel32.COMMSTAT"/> in which the device's status information is returned. If
            this parameter is <c>null</c>, no status information is returned.</param>
        </member>
        <member name="T:AndyB.Comms.Interop.Kernel32.EscapeCode">
            <summary>
            Enumeration of the escape codes.
            </summary>
            <remarks>These correlate to the Win32 API SETxxx and CLRxxx constants.</remarks>
            <seealso cref="M:AndyB.Comms.Interop.Kernel32.EscapeCommFunction(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.EscapeCode)"/>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.EscapeCode.SetXoff">
            <summary>
            Causes transmission to act as if an XOFF character has been received.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.EscapeCode.SetXon">
            <summary>
            Causes transmission to act as if an XON character has been received.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.EscapeCode.SetRts">
            <summary>
            Sends the RTS (request-to-send) signal.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.EscapeCode.ClrRts">
            <summary>
            Clears the RTS (request-to-send) signal.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.EscapeCode.SetDtr">
            <summary>
            Sends the DTR (data-terminal-ready) signal.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.EscapeCode.ClrDtr">
            <summary>
            Clears the DTR (data-terminal-ready) signal.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.EscapeCode.SetBreak">
            <summary>
            Suspends character transmission and places the transmission line in a break state 
            until the ClearCommBreak function is called (or <see cref="M:AndyB.Comms.Interop.Kernel32.EscapeCommFunction(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.EscapeCode)"/> 
            is called with the <see cref="F:AndyB.Comms.Interop.Kernel32.EscapeCode.ClrBreak"/> extended function code). The <see cref="F:AndyB.Comms.Interop.Kernel32.EscapeCode.SetBreak"/> 
            extended function code is identical to the SetCommBreak function. Note that this extended function 
            does not flush data that has not been transmitted.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.EscapeCode.ClrBreak">
            <summary>
            Restores character transmission and places the transmission line in a non-break state. 
            The <see cref="F:AndyB.Comms.Interop.Kernel32.EscapeCode.ClrBreak"/> extended function code is identical to the ClearCommBreak 
            function.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.SETBREAK">
            <summary>
            Suspends character transmission and places the transmission 
            line in a break state until the ClearCommBreak function is 
            called (or EscapeCommFunction is called with the CLRBREAK 
            extended function code). The SETBREAK extended function code 
            is identical to the SetCommBreak function. Note that this 
            extended function does not flush data that has not been 
            transmitted.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Interop.Kernel32.CLRBREAK">
            <summary>
            Restores character transmission and places the transmission 
            line in a non-break state. The CLRBREAK extended function code 
            is identical to the ClearCommBreak function. 
            </summary>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.EscapeCommFunction(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Interop.Kernel32.EscapeCode)">
            <summary>
            The EscapeCommFunction function directs a specified communications device to perform an extended function.
            </summary>
            <param name="hFile">A handle to the communications device. The <see cref="M:AndyB.Comms.Interop.Kernel32.CreateFile(System.String,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)"/>
            function returns a handle.</param>
            <param name="dwFunc">The extended function to perform.  One of the <see cref="T:AndyB.Comms.Interop.Kernel32.EscapeCode"/> enumeration.</param>
            <returns><c>true</c> if the function succeeded; otherwise <c>false</c>.</returns>
            <remarks><para>
            </para></remarks>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.CreateFile(System.String,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
            <summary>
            Creates or opens a file or I/O device. The most commonly used I/O devices are as follows: file, file stream, 
            directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. 
            The function returns a handle that can be used to access the file or device for various types of I/O depending 
            on the file or device and the flags and attributes specified.
            </summary>
            <param name="lpFileName"><para>The name of the file or device to be created or opened. You may use either forward slashes (/) 
            or backslashes (\) in this name.</para>
            <para>In the ANSI version of this function, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide 
            characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming 
            Files, Paths, and Namespaces.</para>
            <para>For information on special device names, see Defining an MS-DOS Device Name.</para>
            <para>To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more information, 
            see File Streams.</para>
            </param>
            <param name="dwDesiredAccess"><para>The requested access to the file or device, which can be summarized as read, write, both or 
            neither zero).
            </para>
            <para>The most commonly used values are GENERIC_READ, GENERIC_WRITE, or both (GENERIC_READ | GENERIC_WRITE). For more 
            information, see Generic Access Rights, File Security and Access Rights, File Access Rights Constants, and ACCESS_MASK.</para>
            <para>If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes 
            without accessing that file or device, even if GENERIC_READ access would have been denied.</para>
            <para>You cannot request an access mode that conflicts with the sharing mode that is specified by the <paramref name="dwShareMode"/> 
            parameter in an open request that already has an open handle.</para>
            <para>For more information, see the Remarks section of this topic and Creating and Opening Files.</para>
            </param>
            <param name="dwShareMode"><para>The requested sharing mode of the file or device, which can be read, write, both, delete, all 
            of these, or none (refer to the following table). Access requests to attributes or extended attributes are not affected by this flag.
            </para>
            <para>If this parameter is zero and CreateFile succeeds, the file or device cannot be shared and cannot be opened again until the 
            handle to the file or device is closed. For more information, see the Remarks section.</para>
            <para>You cannot request a sharing mode that conflicts with the access mode that is specified in an existing request that has an open handle. 
            CreateFile would fail and the GetLastError function would return ERROR_SHARING_VIOLATION.</para>
            <para>To enable a process to share a file or device while another process has the file or device open, use a compatible combination of one 
            or more of the following values. For more information about valid combinations of this parameter with the dwDesiredAccess parameter, see 
            Creating and Opening Files.</para>
            </param>
            <param name="lpSecurityAttributes"><para>A pointer to a SECURITY_ATTRIBUTES structure that contains two separate but related data members: 
            an optional security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child processes.</para>
            <para>This parameter can be NULL.</para>
            <para>If this parameter is NULL, the handle returned by CreateFile cannot be inherited by any child processes the application may create and 
            the file or device associated with the returned handle gets a default security descriptor.</para>
            <para>The lpSecurityDescriptor member of the structure specifies a SECURITY_DESCRIPTOR for a file or device. If this member is NULL, the file 
            or device associated with the returned handle is assigned a default security descriptor.</para>
            <para>CreateFile ignores the lpSecurityDescriptor member when opening an existing file or device, but continues to use the bInheritHandle member.</para>
            <para>The bInheritHandle member of the structure specifies whether the returned handle can be inherited.</para>
            <para>For more information, see the Remarks section.</para>
            </param>
            <param name="dwCreationDisposition"><para>An action to take on a file or device that exists or does not exist.</para>
            <para>For devices other than files, this parameter is usually set to OPEN_EXISTING.</para>
            <para>For more information, see the Remarks section.</para>
            </param>
            <param name="dwFlagsAndAttributes"><para>The file or device attributes and flags, FILE_ATTRIBUTE_NORMAL being the most common default value for files.
            </para>
            <para>This parameter can include any combination of the available file attributes (FILE_ATTRIBUTE_*). All other file attributes override FILE_ATTRIBUTE_NORMAL.</para>
            <para>This parameter can also contain combinations of flags (FILE_FLAG_) for control of file or device caching behavior, access modes, and other special-purpose flags. 
            These combine with any FILE_ATTRIBUTE_ values.</para>
            <para>This parameter can also contain Security Quality of Service (SQOS) information by specifying the SECURITY_SQOS_PRESENT flag. Additional SQOS-related flags information 
            is presented in the table following the attributes and flags tables.</para>
            <para>Note  When CreateFile opens an existing file, it generally combines the file flags with the file attributes of the existing file, and ignores any file attributes supplied as 
            part of dwFlagsAndAttributes. Special cases are detailed in Creating and Opening Files.</para>
            <para>Some of the following file attributes and flags may only apply to files and not necessarily all other types of devices that CreateFile can open. For additional information, 
            see the Remarks section of this topic and Creating and Opening Files.</para>
            <para>For more advanced access to file attributes, see SetFileAttributes. For a complete list of all file attributes with their values and descriptions, see 
            File Attribute Constants.</para>
            </param>
            <param name="hTemplateFile"><para>A valid handle to a template file with the GENERIC_READ access right. The template file supplies file attributes and extended attributes for the 
            file that is being created.</para>
            <para>This parameter can be NULL.</para>
            <para>When opening an existing file, CreateFile ignores this parameter.</para>
            <para>When opening a new encrypted file, the file inherits the discretionary access control list from its parent directory. For additional information, see 
            File Encryption.</para>
            </param>
            <returns><para>If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.</para>
            <para>If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks><para>CreateFile was originally developed specifically for file interaction but has since been expanded and enhanced to include most other types of 
            I/O devices and mechanisms available to Windows developers. This section attempts to cover the varied issues developers may experience when using CreateFile 
            in different contexts and with different I/O types. The text attempts to use the word file only when referring specifically to data stored in an actual file 
            on a file system. However, some uses of file may be referring more generally to an I/O object that supports file-like mechanisms. This liberal use of the 
            term file is particularly prevalent in constant names and parameter names because of the previously mentioned historical reasons.</para>
            <para>
            When an application is finished using the object handle returned by CreateFile, use the CloseHandle function to close the handle. This not only frees up 
            system resources, but can have wider influence on things like sharing the file or device and committing data to disk. Specifics are noted within this topic 
            as appropriate.</para>
            <para>Some file systems, such as the NTFS file system, support compression or encryption for individual files and directories. On volumes that have a mounted 
            file system with this support, a new file inherits the compression and encryption attributes of its directory.
            </para>
            <para>You cannot use CreateFile to control compression, decompression, or decryption on a file or directory. For more information, see Creating and Opening 
            Files, File Compression and Decompression, and File Encryption.
            </para>
            <para>As stated previously, if the lpSecurityAttributes parameter is NULL, the handle returned by CreateFile cannot be inherited by any child processes your 
            application may create. The following information regarding this parameter also applies:
            </para>
            <list type="bullet">
            <item>If the bInheritHandle member variable is not FALSE, which is any nonzero value, then the handle can be inherited. Therefore it is critical this structure 
            member be properly initialized to FALSE if you do not intend the handle to be inheritable.</item>
            <item>The access control lists (ACL) in the default security descriptor for a file or directory are inherited from its parent directory.</item>
            <item>The target file system must support security on files and directories for the lpSecurityDescriptor member to have an effect on them, which can be determined 
            by using GetVolumeInformation.</item>
            </list>
            </remarks>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.GetFileType(Microsoft.Win32.SafeHandles.SafeFileHandle)">
            <summary>
            Retrieves the file type of the specified file.
            </summary>
            <param name="hFile">A handle to the file.</param>
            <returns><para>The function returns one of the following value:</para>
            <list type="table">
            <listheader>
            <term>Return Code/Value</term>
            <description>Description.</description>
            </listheader>
            <item><term>FILE_TYPE_CHAR 0x0002</term><description>The specified file is a character file, typically a LPT device or a console.</description></item>
            <item><term>FILE_TYPE_DISK 0x0001</term><description>The specified file is a disk file.</description></item>
            <item><term>FILE_TYPE_PIPE 0x0003</term><description>The specified file is a socket, a named pipe, or an anonymous pipe.</description></item>
            <item><term>FILE_TYPE_REMOTE 0x8000</term><description>Unused.</description></item>
            <item><term>FILE_TYPE_UNKNOWN 0x0000</term><description>Either the type of the specified type is unknown or the function failed.</description></item>
            </list></returns>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.CloseHandle(Microsoft.Win32.SafeHandles.SafeFileHandle)">
            <summary>
            The CloseHandle function closes an open object handle.
            </summary>
            <param name="hObject">A valid handle to an open object.</param>
            <returns><c>true</c> if the function succeeds; otherwise <c>false</c>.</returns>
            <remarks><para>The CloseHandle function closes handles to the following objects:</para>
            <list type="bullet">
            <item>Access token</item>
            <item>Communications device</item>
            <item>Console input</item>
            <item>Console screen buffer</item>
            <item>Event</item>
            <item>File</item>
            <item>File mapping</item>
            <item>I/O completion port</item>
            <item>Job</item>
            <item>Mailslot</item>
            <item>Memory resource notification</item>
            <item>Mutex</item>
            <item>Named pipe</item>
            <item>Pipe</item>
            <item>Process</item>
            <item>Semaphore</item>
            <item>Thread</item>
            <item>Transaction</item>
            <item>Waitable timer</item>
            </list></remarks>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.WriteFile(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Byte*,System.Int32,System.IntPtr,System.Threading.NativeOverlapped*)">
            <summary>
            The WriteFile function writes data to a file and is designed for both synchronous and asynchronous operation. The function starts writing data 
            to the file at the position indicated by the file pointer. After the write operation has been completed, the file pointer is adjusted by the 
            number of bytes actually written, except when the file is opened with FILE_FLAG_OVERLAPPED. If the file handle was created for overlapped input 
            and output (I/O), the application must adjust the position of the file pointer after the write operation is finished. 
            This function is designed for both synchronous and asynchronous operation. The WriteFileEx function is designed solely for asynchronous operation. 
            It lets an application perform other processing during a file write operation.
            </summary>
            <param name="hFile"><para>A handle to the file or I/O device (for example a file, file stream, physical disk, volume, console buffer, tape drive
            socket, communications resource, mailslot, or pipe).</para>
            <para>The <paramref name="hFile"/> must have been created with write access. For more information, see Generic Access Rights and 
            File Security and Access Rights.</para>
            <para>For asynchronous write operations, <paramref name="hFile"/> can be any handle opened by the CreateFile function using the
            FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
            </para>
            </param>
            <param name="lpBuffer"><para>A pointer to the buffer containing the data to be written to the file or device.</para>
            <para>This buffer must remain valid for the duration of the write function. The caller must not use this buffer
            until the write operation is complete.</para></param>
            <param name="nNumberOfBytesToWrite"><para>THe number of bytes to be written to the file or device.</para>
            <para>A value of zero specifies a null write operation. THe behaviour of a null write operation depends on the
            underlying file system or communications technology.</para></param>
            <param name="lpNumberOfBytesWritten"><para>A pointer to a variable that receives the number of bytes written using
            a synchronous <paramref name="hFile"/> parameter. WriteFile sets this value to zero before doing any work or error checking.
            Use <c>null for this parameter if this is an asynchronous operation to avoid potentially erronous results.</c></para>
            <para>This parameter can only be <c>null</c> when <paramref name="lpOverlapped"/> is not <c>null</c>.</para>
            </param>
            <param name="lpOverlapped"><para>A pointer to an <see cref="T:System.Threading.NativeOverlapped"/> structure is required if the <paramref name="hFile"/>
            was opened with FILE_FLAG_OVERLAPPED, otherwise this parameter can be <c>null</c>.</para>
            <para>For an <paramref name="hFile"/> that supports byte offsets, if you use this parameter you must specify a byte offset
            at which to start writing to the device or file. This offset is specified using the Offset and OffsetHigh members of the
            OVERLAPPED structure. For an <paramref name="hFile"/> that does not support byte offsets, Offset and OffsetHigh are ignored.</para>
            <para>To write to the end of a file, specify both the Offset and OffsetHigh members of the OVERLAPPED structure as 0xFFFFFFFF.
            This is functionally equivalent to previously calling the CreateFile function to open <paramref name="hFile"/> using
            FILE_APPEND_DATA access.</para>
            </param>
            <returns><c>true</c> if the function succeeds; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.WriteFile(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Byte*,System.Int32,System.Int32@,System.IntPtr)">
            <summary>
            The WriteFile function writes data to a file and is designed for both synchronous and asynchronous operation. The function starts writing data 
            to the file at the position indicated by the file pointer. After the write operation has been completed, the file pointer is adjusted by the 
            number of bytes actually written, except when the file is opened with FILE_FLAG_OVERLAPPED. If the file handle was created for overlapped input 
            and output (I/O), the application must adjust the position of the file pointer after the write operation is finished. 
            This function is designed for both synchronous and asynchronous operation. The WriteFileEx function is designed solely for asynchronous operation. 
            It lets an application perform other processing during a file write operation.
            </summary>
            <param name="hFile"><para>A handle to the file or I/O device (for example a file, file stream, physical disk, volume, console buffer, tape drive
            socket, communications resource, mailslot, or pipe).</para>
            <para>The <paramref name="hFile"/> must have been created with write access. For more information, see Generic Access Rights and 
            File Security and Access Rights.</para>
            <para>For asynchronous write operations, <paramref name="hFile"/> can be any handle opened by the CreateFile function using the
            FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
            </para>
            </param>
            <param name="lpBuffer"><para>A pointer to the buffer containing the data to be written to the file or device.</para>
            <para>This buffer must remain valid for the duration of the write function. The caller must not use this buffer
            until the write operation is complete.</para></param>
            <param name="nNumberOfBytesToWrite"><para>THe number of bytes to be written to the file or device.</para>
            <para>A value of zero specifies a null write operation. THe behaviour of a null write operation depends on the
            underlying file system or communications technology.</para></param>
            <param name="lpNumberOfBytesWritten"><para>A pointer to a variable that receives the number of bytes written using
            a synchronous <paramref name="hFile"/> parameter. WriteFile sets this value to zero before doing any work or error checking.
            Use <c>null for this parameter if this is an asynchronous operation to avoid potentially erronous results.</c></para>
            <para>This parameter can only be <c>null</c> when <paramref name="lpOverlapped"/> is not <c>null</c>.</para>
            </param>
            <param name="lpOverlapped"><para>A pointer to an <see cref="T:System.Threading.NativeOverlapped"/> structure is required if the <paramref name="hFile"/>
            was opened with FILE_FLAG_OVERLAPPED, otherwise this parameter can be <c>null</c>.</para>
            <para>For an <paramref name="hFile"/> that supports byte offsets, if you use this parameter you must specify a byte offset
            at which to start writing to the device or file. This offset is specified using the Offset and OffsetHigh members of the
            OVERLAPPED structure. For an <paramref name="hFile"/> that does not support byte offsets, Offset and OffsetHigh are ignored.</para>
            <para>To write to the end of a file, specify both the Offset and OffsetHigh members of the OVERLAPPED structure as 0xFFFFFFFF.
            This is functionally equivalent to previously calling the CreateFile function to open <paramref name="hFile"/> using
            FILE_APPEND_DATA access.</para>
            </param>
            <returns><c>true</c> if the function succeeds; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.ReadFile(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Byte*,System.Int32,System.IntPtr,System.Threading.NativeOverlapped*)">
            <summary>
            <para>Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
            pointer if supported by the device.</para>
            <para>The function is designed for both synchronous and asynchronous operations. For a similar function designed solely
            for asynchronous operation, see ReadFileEx.</para>
            </summary>
            <param name="hFile"><para>A handle to the file or I/O device (for example a file, file stream, physical disk, volume, console buffer, tape drive
            socket, communications resource, mailslot, or pipe).</para>
            <para>The <paramref name="hFile"/> must have been created with read access. For more information, see Generic Access Rights and 
            File Security and Access Rights.</para>
            <para>For asynchronous write operations, <paramref name="hFile"/> can be any handle opened by the CreateFile function using the
            FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
            </para>
            </param>
            <param name="lpBuffer"><para>A pointer to the buffer that receives the data read from a file or device.</para>
            <para>This buffer must remain valid for the duration of the read function. The caller must not use this buffer
            until the read operation is complete.</para></param>
            <param name="nNumberOfBytesToRead">The maximum number of bytes to read.</param>
            <param name="lpNumberOfBytesRead"><para>A pointer to the variable that receives the number of bytes read when
            using a synchronous <paramref name="hFile"/> parameter. ReadFile sets the variable to zero before doing any work
            or error checking. Use <c>null</c> for this parameter if this is an asynchronous operation to avoid potentially
            erroneous results.</para>
            <para>This parameter can be <c>null</c> only when <paramref name="lpOverlapped"/> is not <c>null</c>.</para></param>
            <param name="lpOverlapped"><para>A pointer to an <see cref="T:System.Threading.NativeOverlapped"/> structure is required if the <paramref name="hFile"/>
            was opened with FILE_FLAG_OVERLAPPED, otherwise this parameter can be <c>null</c>.</para>
            <para>For an <paramref name="hFile"/> that supports byte offsets, if you use this parameter you must specify a byte offset
            at which to start reading from the device or file. This offset is specified using the Offset and OffsetHigh members of the
            OVERLAPPED structure. For an <paramref name="hFile"/> that does not support byte offsets, Offset and OffsetHigh are ignored.</para>
            </param>
            <returns><c>true</c> if the function succeeds; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.ReadFile(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Byte*,System.Int32,System.Int32@,System.IntPtr)">
            <summary>
            <para>Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
            pointer if supported by the device.</para>
            <para>The function is designed for both synchronous and asynchronous operations. For a similar function designed solely
            for asynchronous operation, see ReadFileEx.</para>
            </summary>
            <param name="hFile"><para>A handle to the file or I/O device (for example a file, file stream, physical disk, volume, console buffer, tape drive
            socket, communications resource, mailslot, or pipe).</para>
            <para>The <paramref name="hFile"/> must have been created with read access. For more information, see Generic Access Rights and 
            File Security and Access Rights.</para>
            <para>For asynchronous write operations, <paramref name="hFile"/> can be any handle opened by the CreateFile function using the
            FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
            </para>
            </param>
            <param name="lpBuffer"><para>A pointer to the buffer that receives the data read from a file or device.</para>
            <para>This buffer must remain valid for the duration of the read function. The caller must not use this buffer
            until the read operation is complete.</para></param>
            <param name="nNumberOfBytesToRead">The maximum number of bytes to read.</param>
            <param name="lpNumberOfBytesRead"><para>A pointer to the variable that receives the number of bytes read when
            using a synchronous <paramref name="hFile"/> parameter. ReadFile sets the variable to zero before doing any work
            or error checking. Use <c>null</c> for this parameter if this is an asynchronous operation to avoid potentially
            erroneous results.</para>
            <para>This parameter can be <c>null</c> only when <paramref name="lpOverlapped"/> is not <c>null</c>.</para></param>
            <param name="lpOverlapped"><para>A pointer to an <see cref="T:System.Threading.NativeOverlapped"/> structure is required if the <paramref name="hFile"/>
            was opened with FILE_FLAG_OVERLAPPED, otherwise this parameter can be <c>null</c>.</para>
            <para>For an <paramref name="hFile"/> that supports byte offsets, if you use this parameter you must specify a byte offset
            at which to start reading from the device or file. This offset is specified using the Offset and OffsetHigh members of the
            OVERLAPPED structure. For an <paramref name="hFile"/> that does not support byte offsets, Offset and OffsetHigh are ignored.</para>
            </param>
            <returns><c>true</c> if the function succeeds; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.GetOverlappedResult(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Threading.NativeOverlapped*,System.Int32@,System.Boolean)">
            <summary>
            Retrieves the results of an overlapped operation on the specified file, named pipe, or communications device. To
            specify a timeout interval or wait on an alertable thread, use ReadOverlappedResultEx.
            </summary>
            <param name="hFile"><para>A handle to the file, named pipe or communications device. This is the same handle that 
            was specified when the overlapped operation was started by a call to any of the following functions:</para>
            <list type="bullet">
            <item>ReadFile</item>
            <item>WriteFile</item>
            <item>ConnectNamedPipe</item>
            <item>TransactNamedPipe</item>
            <item>DeviceIoControl</item>
            <item>WaitCommEvent</item>
            <item>ReadDirectoryChangesW</item>
            <item>LockFileEx</item>
            <item>ReadDirectoryChangesW</item>
            </list></param>
            <param name="lpOverlapped">A pointer to an OVERLAPPED structure that was specified operation was started.</param>
            <param name="lpNumberOfBytesTransferred">A pointer to a variable that receives the number of bytes that
            were actually transferred by the read or write operation. For a TransactNamedPipe operation this is the number of
            bytes that were read from the pipe. For a DeviceIoControl operation, this is the number of bytes of output data
            returned by the device driver. For a ConnectNamedPipe or WaitCommEvent, the value is undefined.</param>
            <param name="bWait">If this parameter is <c>true</c>, and the Internal member of the <paramref name="lpOverlapped"/>
            structure is STATUS_PENDING, the function does not return until the operation has been completed. If this parameter 
            is <c>false</c> and the operation is still pending, the function returns <c>false</c> and the GetLastError function 
            returns ERROR_IO_INCOMPLETE.</param>
            <returns><c>true</c> if the function succeeds; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.PurgeComm(Microsoft.Win32.SafeHandles.SafeFileHandle,System.UInt32)">
            <summary>
            Discards all characters from the output or input buffer of a specified communications resource. It can also terminate
            pending read or write operations on the resource.
            </summary>
            <param name="hFile">A handle to the communications resource. The <see cref="M:AndyB.Comms.Interop.Kernel32.CreateFile(System.String,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)"/>
            function returns this handle.</param>
            <param name="dwFlags"><para>This parameter can be one of the following values:
            </para>
            <list type="table">
            <listheader><term>Value</term><description>Meaning</description></listheader>
            <item><term>PURGE_RXABORT 0x0002</term><description>Terminates all outstanding overlapped read
            operations and returns immediately, even if read operations have not been completed.</description></item>
            <item><term>PURGE_RXCLEAR 0x0008</term><description>Clears the input buffer (if the device has one).</description></item>
            <item><term>PURGE_TXABORT 0x0001</term><description>Terminates all outstanding overlapped write
            operations and returns immediately, even if the write operations have no been completed.</description></item>
            <item><term>PURGE_TXCLEAR 0x0004</term><description>Clears the output buffer (if the device has one).</description></item>
            </list>
            </param>
            <returns><c>true</c> if the function succeeds; otherwise <c>false</c>.</returns>
            <remarks><para>If a thread uses <see cref="M:AndyB.Comms.Interop.Kernel32.PurgeComm(Microsoft.Win32.SafeHandles.SafeFileHandle,System.UInt32)"/> to flush an output buffer, the deleted characters 
            are not transmitted. To empty the output buffer while ensuring that the contents are transmitted, call the 
            FlushFileBuffers function (a synchronous operation). Note, however, that FlushFileBuffers is subject to flow control but not to 
            write time-outs, and it will not return until all pending write operations have been transmitted.</para></remarks>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.FlushFileBuffers(Microsoft.Win32.SafeHandles.SafeFileHandle)">
            <summary>
            Flushes the buffers of a specified file and cause all buffered data to be written to a file.
            </summary>
            <param name="hFile"><para>A handle to an open file.</para>
            <para>The file handle must have the GENERIC_WRITE access right. For more information, see File and Security.</para>
            <para>If <paramref name="hFile"/> is a handle to a communications device, the function only flushes the transmit buffer.</para>
            <para>If <paramref name="hFile"/> is a handle to the server end of a named pipe, the function does not return until the
            client has read all buffer data from the pipe.</para>
            </param>
            <returns><c>true</c> if the function succeeds; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32.GetLastError">
            <summary>
            Gets the last error from 
            </summary>
            <returns></returns>
        </member>
        <member name="T:AndyB.Comms.Interop.Kernel32Extensions">
            <summary>
            Extension methods for <see cref="T:AndyB.Comms.Interop.Kernel32"/>.
            </summary>
        </member>
        <member name="M:AndyB.Comms.Interop.Kernel32Extensions.HasAny(AndyB.Comms.Interop.Kernel32.CommEvent,AndyB.Comms.Interop.Kernel32.CommEvent)">
            <summary>
            Determines if a enumeration has any of the supplied flags.
            </summary>
            <param name="events">The events enumeration that this method extends.</param>
            <param name="flags">THe set of flags to check for.</param>
            <returns><c>true</c> if the enumerated variable has any of the flags; <c>false</c> otherwise.</returns>
        </member>
        <member name="T:AndyB.Comms.Properties.SR">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.Arg_InvalidSerialPort">
            <summary>
              Looks up a localized string similar to The given port name does not start with COM/com or does not resolve to a valid serial port..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.Arg_InvalidSerialPortExtended">
            <summary>
              Looks up a localized string similar to The given port name is invalid.  It may be a valid port, but not a serial port..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.Arg_SecurityException">
            <summary>
              Looks up a localized string similar to The port name cannot start with &apos;\\&apos;..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.Arg_WrongAsyncResult">
            <summary>
              Looks up a localized string similar to IAsyncResult object did not come from the corresponding async method on this type..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.Argument_InvalidOffLen">
            <summary>
              Looks up a localized string similar to Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.ArgumentNull_Array">
            <summary>
              Looks up a localized string similar to Array cannot be null..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.ArgumentNull_Buffer">
            <summary>
              Looks up a localized string similar to Buffer cannot be null..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.ArgumentOutOfRange_Bounds_Lower_Upper">
            <summary>
              Looks up a localized string similar to Argument must be between {0} and {1}..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.ArgumentOutOfRange_Enum">
            <summary>
              Looks up a localized string similar to Enum value was out of legal range..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.ArgumentOutOfRange_NeedNonNegNumRequired">
            <summary>
              Looks up a localized string similar to Non-negative number required..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.ArgumentOutOfRange_NeedPosNum">
            <summary>
              Looks up a localized string similar to Positive number required..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.ArgumentOutOfRange_OffsetOut">
            <summary>
              Looks up a localized string similar to Either offset did not refer to a position in the string, or there is an insufficient length of destination character array..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.ArgumentOutOfRange_Timeout">
            <summary>
              Looks up a localized string similar to The timeout must be greater than or equal to -1..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.ArgumentOutOfRange_WriteTimeout">
            <summary>
              Looks up a localized string similar to The timeout must be either a positive number or -1.The timeout must be either a positive number or -1..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.BaseStream_Invalid_Not_Open">
            <summary>
              Looks up a localized string similar to The BaseStream is only available when the port is open..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.CanSetWhenDtrDsrHandshake">
            <summary>
              Looks up a localized string similar to Cannot set the state of DTR when DTR/DSR handshaking enabled..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.CanSetWhenRtsCtsHandshake">
            <summary>
              Looks up a localized string similar to Cannot set the state of RTS when RTS/CTS handshaking enabled..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.Cant_be_set_when_open">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; cannot be set while the port is open..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.In_Break_State">
            <summary>
              Looks up a localized string similar to The port is in the break state and cannot be written to..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.IndexOutOfRange_IORaceCondition">
            <summary>
              Looks up a localized string similar to Probable I/O race condition detected while copying memory.  The I/O package is not thread safe by default.  In multithreaded applications, a stream must be accessed in a thread-safe way, such as a thread-safe wrapper returned by TextReader&apos;s or TextWriter&apos;s Synchronized methods.  This also applies to classes like StreamWriter and StreamReader..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.InvalidNullEmptyArgument">
            <summary>
              Looks up a localized string similar to Argument {0} cannot be null or zero-length..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.InvalidOperation_EndReadCalledMultiple">
            <summary>
              Looks up a localized string similar to EndRead can only be called once for each asynchronous operation..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.InvalidOperation_EndWriteCalledMultiple">
            <summary>
              Looks up a localized string similar to EndWrite can only be called once for each asynchronous operation..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.IO_BindHandleFailed">
            <summary>
              Looks up a localized string similar to BindHandle for ThreadPool failed on this handle..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.IO_EOF_ReadBeyondEOF">
            <summary>
              Looks up a localized string similar to Unable to read beyond the end of the stream..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.IO_OperationAborted">
            <summary>
              Looks up a localized string similar to The I/O operation has been aborted because of either a thread exit or an application request..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.IO_PathTooLong">
            <summary>
              Looks up a localized string similar to The specified port name is too long.  The port name must be less than 260 characters..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.IO_PortNotFound">
            <summary>
              Looks up a localized string similar to Serial port not found..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.IO_PortNotFoundFileName">
            <summary>
              Looks up a localized string similar to Serial port %0 not found..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.IO_SharingViolation_File">
            <summary>
              Looks up a localized string similar to The process cannot access the port &apos;{0}&apos; because it is being used by another process..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.IO_SharingViolation_NoFileName">
            <summary>
              Looks up a localized string similar to The process cannot access the port because it is being used by another process..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.IO_UnknownError">
            <summary>
              Looks up a localized string similar to Unknown Error &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.Max_Baud">
            <summary>
              Looks up a localized string similar to The maximum baud rate for the device is {0}..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.NotSupported_UnseekableStream">
            <summary>
              Looks up a localized string similar to Stream does not support seeking..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.NotSupportedEncoding">
            <summary>
              Looks up a localized string similar to SerialPort does not support encoding &apos;{0}&apos;.  The supported encodings include ASCIIEncoding, UTF8Encoding, UnicodeEncoding, UTF32Encoding, and most single or double byte code pages.  For a complete list please see the documentation..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.Port_already_open">
            <summary>
              Looks up a localized string similar to The port is already open..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.Port_not_open">
            <summary>
              Looks up a localized string similar to The port is closed..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.PortNameEmpty_String">
            <summary>
              Looks up a localized string similar to The PortName cannot be empty..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.UnauthorizedAccess_IODenied_NoPathName">
            <summary>
              Looks up a localized string similar to Authorised access to path %0..
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.UnauthorizedAccess_IODenied_Path">
            <summary>
              Looks up a localized string similar to Authorised access to path.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Properties.SR.Write_timed_out">
            <summary>
              Looks up a localized string similar to The write timed out..
            </summary>
        </member>
        <member name="T:AndyB.Comms.Serial.BaudRate">
            <summary>
            Enumeration of baud rates.
            </summary>
            <remarks>Depending of the hardware, the system may reject a particular baud rate if it
            exceeds the maximum value for the port.</remarks>
        </member>
        <member name="F:AndyB.Comms.Serial.BaudRate.Baud75">
            <summary>
            Specifies a baud rate of 75.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.BaudRate.Baud110">
            <summary>
            Specifies a baud rate of 110.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.BaudRate.Baud150">
            <summary>
            Specifies a baud rate of 150.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.BaudRate.Baud300">
            <summary>
            Specifies a baud rate of 300.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.BaudRate.Baud600">
            <summary>
            Specifies a baud rate of 600.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.BaudRate.Baud1200">
            <summary>
            Specifies a baud rate of 1200.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.BaudRate.Baud2400">
            <summary>
            Specifies a baud rate of 2400.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.BaudRate.Baud4800">
            <summary>
            Specifies a baud rate of 4800.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.BaudRate.Baud7200">
            <summary>
            Specifies a baud rate of 7200
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.BaudRate.Baud9600">
            <summary>
            Specifies a baud rate of 9600.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.BaudRate.Baud14400">
            <summary>
            Specifies a baud rate of 14400.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.BaudRate.Baud19200">
            <summary>
            Specifies a baud rate of 19200.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.BaudRate.Baud38400">
            <summary>
            Specifies a baud rate of 38400.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.BaudRate.Baud56K">
            <summary>
            Specifies a baud rate of 56000.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.BaudRate.Baud57600">
            <summary>
            Specifies a baud rate of 57600.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.BaudRate.Baud115200">
            <summary>
            Specifies a baud rate of 115200.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.BaudRate.Baud128K">
            <summary>
            Specifies a baud rate of 128000.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.BaudRate.Baud134_5">
            <summary>
            Specifies a baud rate of 134500.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.BaudRate.Baud256000">
            <summary>
            Specifies a baud rate of 256000.
            </summary>
        </member>
        <member name="T:AndyB.Comms.Serial.CommStatus">
            <summary>
            Enumeration of the various communication status flags.
            </summary>
            <remarks>These values correlate to the Win32 API, in particular the bit pack field of the COMMSTAT structure.</remarks>
            <seealso cref="M:AndyB.Comms.Interop.Kernel32.ClearCommError(Microsoft.Win32.SafeHandles.SafeFileHandle,AndyB.Comms.Serial.SerialError@,AndyB.Comms.Interop.Kernel32.COMMSTAT@)"/>
        </member>
        <member name="F:AndyB.Comms.Serial.CommStatus.CtsHold">
            <summary>
            If this member is <c>true</c>, transmission is waiting for the CTS (clear-to-send) signal to be sent.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.CommStatus.DsrHold">
            <summary>
            If this member is <c>true</c>, transmission is waiting for the DSR (data-set-ready) signal to be sent. 
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.CommStatus.RlsdHold">
            <summary>
            If this member is <c>true</c>, transmission is waiting for the RLSD (receive-line-signal-detect) signal to be sent. 
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.CommStatus.XoffHold">
            <summary>
            If this member is <c>true</c>, transmission is waiting because the XOFF character was received. 
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.CommStatus.XoffSent">
            <summary>
            If this member is <c>true</c>, transmission is waiting because the XOFF character was transmitted. 
            (Transmission halts when the XOFF character is transmitted to a system that takes the next character as XON, 
            regardless of the actual character.)
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.CommStatus.Eof">
            <summary>
            If this member is <c>true</c>, the EOF character has been received.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.CommStatus.TxIm">
            <summary>
            If this member is <c>true</c>, there is a character queued for transmission that has come to the 
            communications device by way of the TransmitCommChar function. The communications device transmits such a 
            character ahead of other characters in the device's output buffer.
            </summary>
        </member>
        <member name="T:AndyB.Comms.Serial.DataBits">
            <summary>
            Enumeration of the number of bits in the transmitted word (byte?).
            </summary>
            <remarks>Do not re-arrange or change these values, as they have to match
            the values used by the Win32 API</remarks>
        </member>
        <member name="F:AndyB.Comms.Serial.DataBits.Five">
            <summary>
            Five bits per data byte.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.DataBits.Six">
            <summary>
            Six bits per data byte.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.DataBits.Seven">
            <summary>
            Seven bits per data byte.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.DataBits.Eight">
            <summary>
            Eight bits per data byte.
            </summary>
        </member>
        <member name="T:AndyB.Comms.Serial.ModemStatus">
            <summary>
            Enumeration of the modem status signals.
            </summary>
            <remarks>These values correspond to the MS_xxxx values
            in the Win32 API.</remarks>
        </member>
        <member name="F:AndyB.Comms.Serial.ModemStatus.Cts">
            <summary>
            The CTS (clear-to-send) signal is on. (MS_CTS_ON)
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.ModemStatus.Dsr">
            <summary>
            The DSR (data-set-ready) signal is on. (MS_DSR_ON)
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.ModemStatus.Ring">
            <summary>
            The RI (ring-indicator) signal is on. (MS_RING_ON)
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.ModemStatus.Rlsd">
            <summary>
            The RLSD (received-line-signal-detect) is on. (MS_RLSD_ON)
            </summary>
        </member>
        <member name="T:AndyB.Comms.Serial.ParityBit">
            <summary>
            Enumeration of the available parity settings.
            </summary>
            <remarks>Do not re-arrange or change these values, as they have to match
            the values used by the Win32 API</remarks>
        </member>
        <member name="F:AndyB.Comms.Serial.ParityBit.None">
            <summary>
            Characters do not have a parity bit.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.ParityBit.Odd">
            <summary>
            Set if there are an odd number of 1s in the character.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.ParityBit.Even">
            <summary>
            Set if there are an even number of 1s in the character.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.ParityBit.Mark">
            <summary>
            The parity bit is always 1.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.ParityBit.Space">
            <summary>
            The parity bit is always 0.
            </summary>
        </member>
        <member name="T:AndyB.Comms.Serial.PinStates">
            <summary>
            RTS and DTR pin states.
            </summary>
            <remarks>Do not re-arrange or change these values, as they have to match
            the values used by the Win32 API</remarks>
        </member>
        <member name="F:AndyB.Comms.Serial.PinStates.Disable">
            <summary>
            Pin is never asserted.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.PinStates.Enable">
            <summary>
            Pin is asserted when port is open.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.PinStates.Handshake">
            <summary>
            Pin is asserted when able to receive data.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.PinStates.Toggle">
            <summary>
            Pin (RTS only) is asserted when transmitting data.
            </summary>
        </member>
        <member name="T:AndyB.Comms.Serial.SerialData">
            <summary>
            Enumeration of the serial data events.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.SerialData.Chars">
            <summary>
            A character has been received.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.SerialData.Eof">
            <summary>
            The eof character has been received.
            </summary>
        </member>
        <member name="T:AndyB.Comms.Serial.SerialDataEventArgs">
            <summary>
            Contains the data for the <see cref="E:AndyB.Comms.Serial.SerialPort.DataReceived"/> event.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialDataEventArgs.EventType">
            <summary>
            Gets the event type that caused this <see cref="T:AndyB.Comms.Serial.SerialDataEventArgs"/>.
            </summary>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialDataEventArgs.#ctor(AndyB.Comms.Serial.SerialData)">
            <summary>
            Initialises a new instance of the <see cref="T:AndyB.Comms.Serial.SerialDataEventArgs"/> class
            with the supplied event type.
            </summary>
            <param name="eventType">The event type.</param>
        </member>
        <member name="T:AndyB.Comms.Serial.SerialError">
            <summary>
            Specifies errors that occur on the <see cref="T:AndyB.Comms.Serial.SerialPort"/> object.
            </summary>
            <remarks>These value match those returned in the Win32 API and correspond to the CE_xxxx values. Do not modify.</remarks>
        </member>
        <member name="F:AndyB.Comms.Serial.SerialError.RxOver">
            <summary>
            An input buffer overflow has occurred. 
            There is either no room in the input buffer, 
            or a character was received after the EOF character.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.SerialError.Overrun">
            <summary>
            A character-buffer overrun has occurred. 
            The next character is lost.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.SerialError.RxParity">
            <summary>
            The hardware detected a parity error.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.SerialError.Frame">
            <summary>
            The hardware detected a framing error.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.SerialError.Break">
            <summary>
            The hardware detected a break condition
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.SerialError.TxFull">
            <summary>
            The application tried to transmit a 
            character, but the output buffer was full.
            </summary>
        </member>
        <member name="T:AndyB.Comms.Serial.SerialErrorReceivedEventArgs">
            <summary>
            Contains the data for the <see cref="E:AndyB.Comms.Serial.SerialPort.ErrorReceived"/> event.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialErrorReceivedEventArgs.EventType">
            <summary>
            Gets the event type for this <see cref="T:AndyB.Comms.Serial.SerialErrorReceivedEventArgs"/>.
            </summary>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialErrorReceivedEventArgs.#ctor(AndyB.Comms.Serial.SerialError)">
            <summary>
            Initialises a new instance of the <see cref="T:AndyB.Comms.Serial.SerialErrorReceivedEventArgs"/>
            with the supplied event type.
            </summary>
            <param name="eventType">The event type.</param>
        </member>
        <member name="T:AndyB.Comms.Serial.SerialPinChange">
            <summary>
            Enumeration of the serial pin changed.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.SerialPinChange.CtsChanged">
            <summary>
            Clear to send.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.SerialPinChange.DsrChanged">
            <summary>
            Data set ready.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.SerialPinChange.CDChanged">
            <summary>
            Received line signal detect (carrier detect).
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.SerialPinChange.Ring">
            <summary>
            Ring Indicator.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.SerialPinChange.Break">
            <summary>
            Break.
            </summary>
        </member>
        <member name="T:AndyB.Comms.Serial.SerialPinChangedEventArgs">
            <summary>
            Contains the data for the <see cref="E:AndyB.Comms.Serial.SerialPort.PinChanged"/> event.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPinChangedEventArgs.EventType">
            <summary>
            Gets the event type that caused this <see cref="T:AndyB.Comms.Serial.SerialPinChangedEventArgs"/>.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPinChangedEventArgs.ModemStatus">
            <summary>
            Gets the status of the modem signals.
            </summary>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialPinChangedEventArgs.#ctor(AndyB.Comms.Serial.SerialPinChange,AndyB.Comms.Serial.ModemStatus)">
            <summary>
            Initialises a new instance of the <see cref="T:AndyB.Comms.Serial.SerialPinChangedEventArgs"/> class
            with the supplied event type.
            </summary>
            <param name="eventType">The event type.</param>
            <param name="modemStatus">The status of the modem signals.</param>
        </member>
        <member name="T:AndyB.Comms.Serial.SerialPort">
            <summary>
            Implements a serial port object.
            </summary>
            <remarks><para>The <see cref="T:AndyB.Comms.Serial.SerialPort"/> class provides a rich set of methods and properties for serial 
            communications.</para>
            <para>If you perform multiple asynchronous operations on a <see cref="T:AndyB.Comms.Serial.SerialPort"/>, they do not 
            necessarily complete in the order in which they are started.</para>
            </remarks>
        </member>
        <member name="F:AndyB.Comms.Serial.SerialPort.InfiniteTimeout">
            <summary>
            Indicates that no time-out should occur.
            </summary>
            <remarks>This value is used with the ReadTimeout and WriteTimeout properties.</remarks>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.IsAsync">
            <summary>
            Determines if the port has been opened for overlapped (async) operations.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.InBreak">
            <summary>
            Determines if the port is in the break state (user set).
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.Handle">
            <summary>
            Gets the handle for the communications port.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.IsOpen">
            <summary>
            Gets a value that indicates whether a <see cref="T:AndyB.Comms.Serial.SerialPort"/> is connected.
            </summary>
            <value><c>true</c> if the <see cref="T:AndyB.Comms.Serial.SerialPort"/> is connected; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.PortName">
            <summary>
            Gets or sets the name of the comm port, including but not limited to all available COM ports.
            </summary>
            <exception cref="T:System.ArgumentException"><para>The <see cref="P:AndyB.Comms.Serial.SerialPort.PortName"/> property was set to a value with a length of zero.</para>
            <para>The <see cref="P:AndyB.Comms.Serial.SerialPort.PortName"/> property was set to a value that starts with "\\".</para>
            <para>The <see cref="P:AndyB.Comms.Serial.SerialPort.PortName"/> was not not valid.</para></exception>
            <exception cref="T:System.ArgumentNullException">The <see cref="P:AndyB.Comms.Serial.SerialPort.PortName"/> property was set to a null reference.</exception>
            <exception cref="T:System.InvalidOperationException">The port is already open.</exception>
            <remarks>The list of valid port names can be obtained using the <see cref="M:AndyB.Comms.Serial.SerialPort.GetPortNames"/> method.</remarks>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.ModemStatus">
            <summary>
            Gets the status of the modem pins.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.Dtr">
            <summary>
            Sets the state of the DTR pin.
            </summary>
            <remarks><para>The DTR pin can only be controlled when the state of the DCB FDTRCONTROL is set to DISABLE or ENABLE.
            </para></remarks>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.Rts">
            <summary>
            Sets the state of the RTS pin.
            </summary>
            <remarks><para>The RTS pin can only be controlled when the state of the DCB FRTSCONTROL is set to DISABLE or ENABLE.
            </para></remarks>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.XonXoff">
            <summary>
            Sets the state of XonXoff.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.Break">
            <summary>
            Sets the break state.
            </summary>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialPort.RxPurge">
            <summary>
            Purges the receive queue.
            </summary>
            <remarks><para>This method will cause any pending reads to be completed as well as emptying the
            receive buffers.</para></remarks>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialPort.TxPurge">
            <summary>
            Purges the transmit queue.
            </summary>
            <remarks><para>This method will cause any pending writes to be completed as well as emptying the
            transmit buffers.</para></remarks>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialPort.#ctor">
            <summary>
            Initialises a new instance of the <see cref="T:AndyB.Comms.Serial.SerialPort"/> class.
            </summary>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialPort.#ctor(System.String)">
            <summary>
            Initialises a new instance of the <see cref="T:AndyB.Comms.Serial.SerialPort"/> with the specified portname.
            </summary>
            <param name="portName">A <see cref="T:System.String"/> containing the comm port to use for subsequent
            operations.</param>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialPort.#ctor(System.String,AndyB.Comms.Serial.BaudRate)">
            <summary>
            Initialises a new instance of the <see cref="T:AndyB.Comms.Serial.SerialPort"/> with the specified portname.
            </summary>
            <param name="portName">A <see cref="T:System.String"/> containing the comm port to use for subsequent
            operations.</param>
            <param name="baudRate">One of the <see cref="P:AndyB.Comms.Serial.SerialPort.BaudRate"/> enumeration values representing the baudrate
            of the line.</param>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialPort.#ctor(System.String,AndyB.Comms.Serial.BaudRate,AndyB.Comms.Serial.DataBits)">
            <summary>
            Initialises a new instance of the <see cref="T:AndyB.Comms.Serial.SerialPort"/> with the specified portname.
            </summary>
            <param name="portName">A <see cref="T:System.String"/> containing the comm port to use for subsequent
            operations.</param>
            <param name="baudRate">One of the <see cref="P:AndyB.Comms.Serial.SerialPort.BaudRate"/> enumeration values representing the baudrate
            of the line.</param>
            <param name="dataBits">One of the <see cref="T:AndyB.Comms.Serial.DataBits"/> enumeration values representing the number of
            data bits.</param>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialPort.#ctor(System.String,AndyB.Comms.Serial.BaudRate,AndyB.Comms.Serial.DataBits,AndyB.Comms.Serial.ParityBit)">
            <summary>
            Initialises a new instance of the <see cref="T:AndyB.Comms.Serial.SerialPort"/> with the specified portname.
            </summary>
            <param name="portName">A <see cref="T:System.String"/> containing the comm port to use for subsequent
            operations.</param>
            <param name="baudRate">One of the <see cref="P:AndyB.Comms.Serial.SerialPort.BaudRate"/> enumeration values representing the baudrate
            of the line.</param>
            <param name="dataBits">One of the <see cref="T:AndyB.Comms.Serial.DataBits"/> enumeration values representing the number of
            data bits.</param>
            <param name="parity">One of the <see cref="P:AndyB.Comms.Serial.SerialPort.Parity"/> enumeration values representing the
            type of parity present.</param>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialPort.#ctor(System.String,AndyB.Comms.Serial.BaudRate,AndyB.Comms.Serial.DataBits,AndyB.Comms.Serial.ParityBit,AndyB.Comms.Serial.StopBits)">
            <summary>
            Initialises a new instance of the <see cref="T:AndyB.Comms.Serial.SerialPort"/> with the specified portname.
            </summary>
            <param name="portName">A <see cref="T:System.String"/> containing the comm port to use for subsequent
            operations.</param>
            <param name="baudRate">One of the <see cref="P:AndyB.Comms.Serial.SerialPort.BaudRate"/> enumeration values representing the baudrate
            of the line.</param>
            <param name="dataBits">One of the <see cref="T:AndyB.Comms.Serial.DataBits"/> enumeration values representing the number of
            data bits.</param>
            <param name="parity">One of the <see cref="P:AndyB.Comms.Serial.SerialPort.Parity"/> enumeration values representing the
            type of parity present.</param>
            <param name="stopBits">One of the <see cref="P:AndyB.Comms.Serial.SerialPort.StopBits"/> enumeration values representing the
            number of stop bits.</param>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialPort.Dispose">
            <summary>
            Releases the managed resources used by the <see cref="T:AndyB.Comms.Serial.SerialPort"/>.
            </summary>
            <remarks><para>Call <see cref="M:System.IDisposable.Dispose"/> when you are finished using the 
            <see cref="T:AndyB.Comms.Serial.SerialPort"/>. The <see cref="M:System.IDisposable.Dispose"/> method leaves the 
            <see cref="T:AndyB.Comms.Serial.SerialPort"/> in an unusable state. After calling <see cref="M:System.IDisposable.Dispose"/>, 
            you must release all references to the <see cref="T:AndyB.Comms.Serial.SerialPort"/> so the garbage collector can 
            reclaim the memory that the <see cref="T:AndyB.Comms.Serial.SerialPort"/> was occupying. For more information, see 
            Cleaning Up Unmanaged Resources and Implementing a Dispose Method.</para>
            <para>Note: Always call <see cref="M:System.IDisposable.Dispose"/> before you release your last 
            reference to the <see cref="T:AndyB.Comms.Serial.SerialPort"/>. Otherwise, the resources it is using will not be freed 
            until the garbage collector calls the <see cref="T:AndyB.Comms.Serial.SerialPort"/> object's <see cref="M:AndyB.Comms.Serial.SerialPort.Finalize"/> method.</para>
            </remarks>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialPort.Dispose(System.Boolean)">
            <summary>
            Releases the managed resources used by the <see cref="T:AndyB.Comms.Serial.SerialPort"/>, and optionally disposes of the
            managed resources.
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; 
            <c>false</c> to releases only unmanaged resources.</param>
            <remarks><para>This method is called by the public <see cref="M:AndyB.Comms.Serial.SerialPort.Dispose"/> method and the 
            <see cref="M:AndyB.Comms.Serial.SerialPort.Finalize"/> method. <see cref="M:AndyB.Comms.Serial.SerialPort.Dispose"/> invokes the protected 
            <see cref="M:AndyB.Comms.Serial.SerialPort.Dispose(System.Boolean)"/> method with the disposing parameter set to <c>true</c>.
            <see cref="M:AndyB.Comms.Serial.SerialPort.Finalize"/> invokes <see cref="M:AndyB.Comms.Serial.SerialPort.Dispose(System.Boolean)"/> with disposing set to <c>false</c>.</para>
            <para>When the disposing parameter is <c>true</c>, this method releases all resources held by any 
            managed objects that this <see cref="T:AndyB.Comms.Serial.SerialPort"/> references. This method invokes the 
            <see cref="M:AndyB.Comms.Serial.SerialPort.Dispose"/> method of each referenced object.</para>
            </remarks>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialPort.Finalize">
            <summary>
            Use C# destructor syntax for finalization code.
            This destructor will run only if the Dispose method 
            does not get called.
            It gives your base class the opportunity to finalize.
            Do not provide destructors in types derived from this class.
            </summary>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialPort.GetPortNames">
            <summary>
            Gets an array of serial port names for the current computer.
            </summary>
            <returns>An array of serial port names for the current computer.</returns>
            <remarks><para>The order of port names returned from <see cref="M:AndyB.Comms.Serial.SerialPort.GetPortNames"/> is not specified.</para>
            <para>Use the <see cref="M:AndyB.Comms.Serial.SerialPort.GetPortNames"/> method to query the current computer for a list of 
            valid serial port names. For example, you can use this method to determine whether COM1 and COM2 
            are valid serial ports for the current computer.</para>
            <para>In Windows 98 environments, the port names are obtained from the system registry 
            (HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\SERIALCOMM). If the registry contains stale or otherwise 
            incorrect data then the <see cref="M:AndyB.Comms.Serial.SerialPort.GetPortNames"/> method will return incorrect data.</para>
            </remarks>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.BaudRate">
            <summary>
            Gets/Sets the baud rate
            </summary>
            <value>One of the <see cref="P:AndyB.Comms.Serial.SerialPort.BaudRate"/> values.</value>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.DataBits">
            <summary>
            Gets/Sets the word length of the UART.
            </summary>
            <value>One of the <see cref="P:AndyB.Comms.Serial.SerialPort.DataBits"/> values.</value>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.Parity">
            <summary>
            Gets/Sets the parity
            </summary>
            <value>One of the <see cref="P:AndyB.Comms.Serial.SerialPort.Parity"/> values.</value>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.StopBits">
            <summary>
            Gets/Sets the number of stop bits
            </summary>
            <value>One of the <see cref="P:AndyB.Comms.Serial.SerialPort.StopBits"/> values.</value>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.XonXoffHandshake">
            <summary>
            Gets/Set XON/XOFF handshaking.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.DtrDsrHandshake">
            <summary>
            Gets/sets DTR/DSR handshaking.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.RtsCtsHandshake">
            <summary>
            Gets/set RTS/CTS handshaking.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.DtrEnable">
            <summary>
            Enables or disables the DTR (data terminal ready) pin.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.RtsEnable">
            <summary>
            Enables or disables the RTS (Request To Send) pin.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.TxFlowCts">
            <summary>
            Enables or disables RTS/CTS flow control.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.TxFlowDsr">
            <summary>
            Enables or disables DTR/DSR flow control?
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.DtrControl">
            <summary>
            Gets/sets DTR pin control.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.RtsControl">
            <summary>
            Gets/sets RTS pin control.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.RxDsrSensitivity">
            <summary>
            Gets/sets RX DSR Sensitivity.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.TxContinue">
            <summary>
            Gets/sets TX Continue.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.TxFlowXoff">
            <summary>
            Gets/sets TX Flow Xoff.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.RxFlowXoff">
            <summary>
            Gets/sets RX Flow Xoff.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.XoffCharacter">
            <summary>
            Gets/Sets the XOFF character
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.XonCharacter">
            <summary>
            Gets/Sets the XON character
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.ErrorChar">
            <summary>
            Gets/Sets the error character.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.EofChar">
            <summary>
            Gets/Sets the eof character.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.EventChar">
            <summary>
            Gets/Sets the event character.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.PackedValues">
            <summary>
            Gets the packets values from DCB.
            </summary>
        </member>
        <member name="E:AndyB.Comms.Serial.SerialPort.DataReceived">
            <summary>
            Represents the method that will handle the received data event of a <see cref="T:AndyB.Comms.Serial.SerialPort"/>.
            </summary>
            <remarks><para>Serial received events are caused by data being received on the serial port.</para>
            <para><see cref="E:AndyB.Comms.Serial.SerialPort.PinChanged"/>, <see cref="E:AndyB.Comms.Serial.SerialPort.DataReceived"/>, and <see cref="E:AndyB.Comms.Serial.SerialPort.ErrorReceived"/> events 
            may be called out of order, and there may be a slight delay between when the underlying stream reports 
            the error and when the event handler is executed. Only one event handler can execute at a time.</para>
            <para>The <see cref="E:AndyB.Comms.Serial.SerialPort.DataReceived"/> event is raised on a secondary thread.</para>
            <para>For more information about handling events, see Consuming Events.</para>
            </remarks>        
        </member>
        <member name="E:AndyB.Comms.Serial.SerialPort.PinChanged">
            <summary>
            Represents the method that will handle the modem pins changed event of a <see cref="T:AndyB.Comms.Serial.SerialPort"/>.
            </summary>
            <remarks><para>Serial pin changed events can be caused by any of the items in the 
            <see cref="P:AndyB.Comms.Serial.SerialPort.ModemStatus"/> enumeration. Because the operating system determines whether to raise 
            this event or not, not all events may be reported. As part of the event, the new value of the pin is 
            set.</para>
            <para>The <see cref="E:AndyB.Comms.Serial.SerialPort.PinChanged"/> event is raised when a <see cref="T:AndyB.Comms.Serial.SerialPort"/> object enters the 
            BreakState, but not when the port exits the BreakState. This behaviour does not apply to other values 
            in the <see cref="P:AndyB.Comms.Serial.SerialPort.ModemStatus"/> enumeration.</para>
            <para><see cref="E:AndyB.Comms.Serial.SerialPort.PinChanged"/>, <see cref="E:AndyB.Comms.Serial.SerialPort.DataReceived"/>, and <see cref="E:AndyB.Comms.Serial.SerialPort.ErrorReceived"/> events 
            may be called out of order, and there may be a slight delay between when the underlying stream reports 
            the error and when the event handler is executed. Only one event handler can execute at a time.</para>
            <para>The <see cref="E:AndyB.Comms.Serial.SerialPort.PinChanged"/> event is raised on a secondary thread.</para>
            <para>For more information about handling events, see Consuming Events.</para>
            </remarks>
        </member>
        <member name="E:AndyB.Comms.Serial.SerialPort.ErrorReceived">
            <summary>
            Represents the method that will handle the error detected event of a <see cref="T:AndyB.Comms.Serial.SerialPort"/> object.
            </summary>
            <remarks><para>Error events can be caused by any of the items in the 
            <see cref="T:AndyB.Comms.Serial.SerialError"/> enumeration. Because the operating system determines whether to raise 
            this event or not, not all events may be reported.</para>
            <para><see cref="E:AndyB.Comms.Serial.SerialPort.PinChanged"/>, <see cref="E:AndyB.Comms.Serial.SerialPort.DataReceived"/>, and <see cref="E:AndyB.Comms.Serial.SerialPort.ErrorReceived"/> events 
            may be called out of order, and there may be a slight delay between when the underlying stream reports 
            the error and when the event handler is executed. Only one event handler can execute at a time.</para>
            <para>The <see cref="E:AndyB.Comms.Serial.SerialPort.ErrorReceived"/> event is raised on a secondary thread.</para>
            <para>For more information about handling events, see Consuming Events.</para>
            </remarks>
        </member>
        <member name="E:AndyB.Comms.Serial.SerialPort.TxEmpty">
            <summary>
            Represents the method that will handle the port transmitter completed event.
            </summary>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialPort.Open">
            <summary>
            Establishes a serial port connection.
            </summary>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialPort.Close">
            <summary>
            Closes the <see cref="T:AndyB.Comms.Serial.SerialPort"/> connection and releases all associated resources. 
            </summary>
            <remarks>The <see cref="M:AndyB.Comms.Serial.SerialPort.Close"/> method closes the connection and releases all managed and 
            unmanaged resources associated with the <see cref="T:AndyB.Comms.Serial.SerialPort"/>. Upon closing, the 
            <see cref="P:AndyB.Comms.Serial.SerialPort.IsOpen"/> property is set to <c>false</c>.</remarks>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.BaseStream">
            <summary>
            Gets the underlying stream for standard read/write functions.
            </summary>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialPort.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a specified number of bytes to the serial port using data from a buffer.
            </summary>
            <param name="buffer">The byte array that contains the data to write to the port.</param>
            <param name="offset">The zero based offset in the buffer at which to begin copying bytes to the port.</param>
            <param name="count">The number of bytes to write.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">The specified port is not open.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="offset"/> or <paramref name="count"/> parameters are outside a valid
            region of <paramref name="buffer"/> being passed. Either <paramref name="offset"/> or
            <paramref name="count"/> is less than zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="offset"/> plus <paramref name="count"/> is greater than
            the length of the buffer.</exception>
            <exception cref="T:System.TimeoutException">The operation did not complete before the time-out period ended.</exception>
            <remarks>If <paramref name="buffer"/> length is 0, then the function returns immediately.</remarks>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialPort.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a specified number of bytes from the serial port.
            </summary>
            <param name="buffer">The byte array that the data will be written to.</param>
            <param name="offset">The zero based offset in the buffer at which to begin copying bytes from the port.</param>
            <param name="count">The maximum number of bytes to read.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">The specified port is not open.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="offset"/> or <paramref name="count"/> parameters are outside a valid
            region of <paramref name="buffer"/> being passed. Either <paramref name="offset"/> or
            <paramref name="count"/> is less than zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="offset"/> plus <paramref name="count"/> is greater than
            the length of the buffer.</exception>
            <exception cref="T:System.TimeoutException">The operation did not complete before the time-out period ended.</exception>
            <returns>The count of bytes read into the buffer.</returns>
            <remarks>If <paramref name="buffer"/> length is 0, then the function returns immediately.</remarks>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.PortStatus">
            <summary>
            Gets the status of the comm port.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.RxQueueCount">
            <summary>
            Gets the count of the bytes received by the serial provider but no yet read
            by a ReadFile operation.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.TxQueueCount">
            <summary>
            Gets a count of the user data remaining to be transmitted for all write operations.
            This value will be zero for a non-overlapped write.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.RxTimeout">
            <summary>
            Gets or sets a value that specifies the amount of time after which a synchronous <see cref="M:AndyB.Comms.Serial.SerialPort.Read(System.Byte[],System.Int32,System.Int32)"/>
            call will time out. 
            </summary>
            <value>The time-out value, in milliseconds. The default value is 0, which indicates an infinite 
            time-out period.</value>
            <remarks>This option applies to synchronous <see cref="M:AndyB.Comms.Serial.SerialPort.Read(System.Byte[],System.Int32,System.Int32)"/> calls only. If the time-out period 
            is exceeded, the <see cref="M:AndyB.Comms.Serial.SerialPort.Read(System.Byte[],System.Int32,System.Int32)"/> method will throw a <see cref="T:System.TimeoutException"/>.
            </remarks>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.RxIntervalTimeout">
            <summary>
            Gets or sets a value that specifies the amount of time between second and
            subsequent characters after which a synchronous <see cref="M:AndyB.Comms.Serial.SerialPort.Read(System.Byte[],System.Int32,System.Int32)"/> call will time out.
            </summary>
            <value>The time-out value, in milliseconds. The default value is 0, which indicates the property is
            not used.</value>
            <remarks>This option applies to synchronous <see cref="M:AndyB.Comms.Serial.SerialPort.Read(System.Byte[],System.Int32,System.Int32)"/> calls only. If the time-out period 
            is exceeded, the <see cref="M:AndyB.Comms.Serial.SerialPort.Read(System.Byte[],System.Int32,System.Int32)"/> method will throw a <see cref="T:System.TimeoutException"/>.
            </remarks>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.RxMultiplierTimeout">
            <summary>
            Gets/set the read multiplier timeout.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.TxTimeout">
            <summary>
            Gets or sets a value that specifies the amount of time after which a synchronous <see cref="M:AndyB.Comms.Serial.SerialPort.Write(System.Byte[],System.Int32,System.Int32)"/>
            call will time out. 
            </summary>
            <value>The time-out value, in milliseconds. If you set the property with a value between 1 and 499,
            the value will be changed to 100.  The default value is 0, which indicates an infinite 
            time-out period.</value>
            <remarks>This option applies to synchronous <see cref="M:AndyB.Comms.Serial.SerialPort.Write(System.Byte[],System.Int32,System.Int32)"/> calls only. If the time-out period 
            is exceeded, the <see cref="M:AndyB.Comms.Serial.SerialPort.Write(System.Byte[],System.Int32,System.Int32)"/> method will throw a <see cref="T:System.TimeoutException"/>.
            </remarks>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPort.TxMultiplierTimeout">
            <summary>
            Gets/set the transmit multiplier timeout.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPortAsyncResult.UserCallback">
            <summary>
            Gets/set the delegate that will be called when the operation completes.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPortAsyncResult.IsWrite">
            <summary>
            Gets/sets if this asynchronous operation is a write.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPortAsyncResult.Overlapped">
            <summary>
            Gets/set the point to the native overlapped structure.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPortAsyncResult.ErrorCode">
            <summary>
            Gets/sets the windows error code
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPortAsyncResult.NumBytes">
            <summary>
            Gets/sets the number of bytes transferred.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPortAsyncResult.EndXxxCalled">
            <summary>
            Determines if we've called EndXxx already.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPortAsyncResult.AsyncState">
            <inheritdoc/>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPortAsyncResult.AsyncWaitHandle">
            <inheritdoc/>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPortAsyncResult.CompletedSynchronously">
            <summary>
            Returns <c>true</c> if the user callback was called by the thread that
            called BeginRead or BeginWrite.  If we use an async delegate or
            threadpool thread internally, this will be <c>false</c>.  This is
            used by code to determine whether a successive call to BeginRead needs
            to be done on their main thread or in their callback to avoid a
            stack overflow on many reads or writes.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialPortAsyncResult.IsCompleted">
            <summary>
            Gets/set if the asynchronous operation has completed.
            </summary>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialPortAsyncResult.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:AndyB.Comms.Serial.SerialSettings">
            <summary>
            A class of settings used with the <see cref="T:AndyB.Comms.Serial.SerialPort"/> object.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialSettings.Name">
            <summary>
            Gets/Sets the port name.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialSettings.Baudrate">
            <summary>
            Gets/Sets the baud rate of the <see cref="T:AndyB.Comms.Serial.SerialPort"/> object.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialSettings.DataBits">
            <summary>
            Gets/Sets the number of data bits of the <see cref="T:AndyB.Comms.Serial.SerialPort"/> object.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialSettings.Parity">
            <summary>
            Gets/Sets the parity setting of the <see cref="T:AndyB.Comms.Serial.SerialPort"/> object.
            </summary>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialSettings.StopBits">
            <summary>
            Gets/Sets the stop bits of the <see cref="T:AndyB.Comms.Serial.SerialPort"/> object.
            </summary>
        </member>
        <member name="T:AndyB.Comms.Serial.SerialStream">
            <summary>
            An stream object for an underlying serial port.
            </summary>
            <remarks><para>The stream is always opened via the <see cref="T:AndyB.Comms.Serial.SerialStream"/> constructor.</para>
            <para>Lifetime of the Comm port handle is controlled via a <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle"/>.
            Thus all properties are available only when the <see cref="T:AndyB.Comms.Serial.SerialStream"/> is open and not disposed.
            </para>
            <para>Handles to serial communication resources here always:</para>
            <list type="bullet">
            <item><para>Own the handle</para></item>
            <item><para>Are opened for asynchronous operation</para></item>
            <item><para>Set _access at the level of FileAccess.ReadWrite</para></item>
            <item><para>Allow for reading and writing</para></item>
            <item><para>Disallow seeking, since they encapsulate a file of type FILE_TYPE_CHAR</para></item>
            </list></remarks>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialStream.#ctor(AndyB.Comms.Serial.SerialPort)">
            <summary>
            Initialise a new instance of the <see cref="T:AndyB.Comms.Serial.SerialStream"/> class
            for the supplied handle.
            </summary>
            <param name="port">The serial port that is this stream.</param>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialStream.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialStream.CanSeek">
            <inheritdoc/>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialStream.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialStream.Length">
            <inheritdoc/>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialStream.Position">
            <inheritdoc/>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialStream.Flush">
            <inheritdoc/>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc/>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialStream.SetLength(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialStream.CanTimeout">
            <inheritdoc/>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialStream.WriteTimeout">
            <inheritdoc/>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialStream.EndWrite(System.IAsyncResult)">
            <summary>
            Ends an asynchronous Write started by <see cref="M:AndyB.Comms.Serial.SerialStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)"/>.
            </summary>
            <param name="asyncResult">The <see cref="T:AndyB.Comms.Serial.SerialPortAsyncResult"/> returned from the <see cref="M:AndyB.Comms.Serial.SerialStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)"/> call.</param>
            <exception cref="T:System.InvalidOperationException">The port is in break state.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult"/> is <c>null</c> or not a type of
            <see cref="T:AndyB.Comms.Serial.SerialPortAsyncResult"/>.</exception>
        </member>
        <member name="P:AndyB.Comms.Serial.SerialStream.ReadTimeout">
            <inheritdoc/>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:AndyB.Comms.Serial.SerialStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:AndyB.Comms.Serial.StopBits">
            <summary>
            Enumeration of the available stop bits
            </summary>
            <remarks>Do not re-arrange or change these values, as they have to match
            the values used by the Win32 API</remarks>
        </member>
        <member name="F:AndyB.Comms.Serial.StopBits.One">
            <summary>
            Line is asserted for 1 bit duration at end of each character.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.StopBits.OnePointFive">
            <summary>
            Line is asserted for 1.5 bit duration at end of each character.
            </summary>
        </member>
        <member name="F:AndyB.Comms.Serial.StopBits.Two">
            <summary>
            Line is asserted for 2 bit duration at end of each character.
            </summary>
        </member>
    </members>
</doc>
